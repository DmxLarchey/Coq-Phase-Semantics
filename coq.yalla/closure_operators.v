(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*         CeCILL v2 FREE SOFTWARE LICENSE AGREEMENT          *)
(**************************************************************)

(*   Adapted by Olivier Laurent [**]                          *)
(*                                                            *)
(*                              [**] Affiliation LIP -- CNRS  *)


Require Import CRelationClasses CMorphisms.
Require Import List_Type.

Require Import utils_tac.

Set Implicit Arguments.

(* equivalence at Type *)
Notation "X â‰¡ Y" := ((X->Y)*(Y->X))%type (at level 80, format "X  â‰¡  Y", no associativity).

Section ClosurePreOrder.

  Context { M : Type }.

  (* TODO equivalence generated by a PreOrder *)
  Definition eqrel (S : M -> M -> Type) x y := ((S x y) * (S y x))%type.

  Global Instance eqrel_refl S (POS : PreOrder S) : Reflexive (eqrel S) :=
    fun x => (@PreOrder_Reflexive _ _ POS x, @PreOrder_Reflexive _ _ POS x).
  Global Instance eqrel_sym S (POS : PreOrder S) : Symmetric (eqrel S) :=
    fun _ _ H => match H with (H1, H2) => (H2, H1) end.
  Global Instance eqrel_trans S (POS : PreOrder S) : Transitive (eqrel S) :=
    fun _ _ _ P Q =>
    match P, Q with (P1,P2), (Q1,Q2) => (@PreOrder_Transitive _ _ POS _ _ _ P1 Q1,
                                         @PreOrder_Transitive _ _ POS _ _ _ Q2 P2) end.
  Global Instance eqrel_equiv S (POS : PreOrder S) : Equivalence (eqrel S) :=
    { Equivalence_Reflexive := eqrel_refl POS;
      Equivalence_Symmetric := eqrel_sym POS;
      Equivalence_Transitive := eqrel_trans POS }.

  Global Instance eq_eqrel S (POS : PreOrder S) : Proper (eq ==> eqrel S) id.
  Proof. split; subst; reflexivity. Qed.

  Context { R : M -> M -> Type }.
  Variable PO : PreOrder R.

  Infix "â‰¤" := R (at level 75, no associativity).
  Infix "â‰ƒ" := (eqrel R) (at level 75, no associativity).

  Hint Resolve (eqrel_refl PO) (eqrel_trans PO).
  Hint Immediate (eqrel_sym PO).

  Class ClosureOp := {
    cl          : M -> M;
    cl_increase : forall x, x â‰¤ cl x;
    cl_monotone : forall x y, x â‰¤ y -> cl x â‰¤ cl y;
    cl_idempotent : forall x, cl (cl x) â‰¤ cl x }.

  Context { CL : ClosureOp }.

  Proposition cl_le x y : x â‰¤ cl y -> cl x â‰¤ cl y.
  Proof.
  intros; transitivity (cl (cl y)); [ apply cl_monotone; assumption | apply cl_idempotent ].
  Qed.

  Proposition le_cl x y : cl x â‰¤ cl y -> x â‰¤ cl y.
  Proof. intros ; transitivity (cl x); [ apply cl_increase | assumption ]. Qed.

  Fact cl_eq A B : A â‰ƒ B -> cl A â‰ƒ cl B.
  Proof. intros []; split; apply cl_monotone; assumption. Qed.

  Notation closed := (fun x => cl x â‰¤ x).

  Fact cl_closed x y : closed y -> x â‰¤ y -> cl x â‰¤ y.
  Proof. intros; transitivity (cl y); [ apply cl_monotone | ] ; assumption. Qed.

End ClosurePreOrder.


Section ClosureMagma.

  Context { M : Type } { R : M -> M -> Type }.
  Variable PO : PreOrder R.
  Context { CL : @ClosureOp _ R }.

  Hint Resolve (@PreOrder_Reflexive _ _ PO).
  Hint Resolve (@cl_increase _ _ CL) (@cl_monotone _ _ CL) (@cl_idempotent _ _ CL).

  Variable compose : M -> M -> M.

  Infix "â‰¤" := R (at level 75, no associativity).
  Infix "â‰ƒ" := (eqrel R) (at level 75, no associativity).
  Infix "â€¢" := compose (at level 45, no associativity).
  Notation closed := (fun x => cl x â‰¤ x).

  Hypothesis compose_monotone : Proper (R ==> R ==> R) compose.

  Hint Resolve compose_monotone.


  (* Stability *)

  Definition cl_stability   := forall x y, cl x â€¢ cl y â‰¤ cl (x â€¢ y).
  Definition cl_stability_l := forall x y, cl x â€¢    y â‰¤ cl (x â€¢ y).
  Definition cl_stability_r := forall x y,    x â€¢ cl y â‰¤ cl (x â€¢ y).

  Proposition cl_stable_imp_stable_l : cl_stability -> cl_stability_l.
  Proof.
  intros Hs x y.
  transitivity (cl x â€¢ cl y); auto.
  apply compose_monotone; auto.
  Qed.

  Proposition cl_stable_imp_stable_r : cl_stability -> cl_stability_r.
  Proof.
  intros Hs x y.
  transitivity (cl x â€¢ cl y); auto.
  apply compose_monotone; auto.
  Qed.

  Proposition cl_stable_lr_imp_stable : cl_stability_l -> cl_stability_r -> cl_stability.
  Proof.
  intros Hsl Hsr x y.
  etransitivity; [ | apply cl_idempotent ].
  transitivity (cl (cl x â€¢ y)); auto.
  Qed.

  Hint Resolve cl_stable_imp_stable_l cl_stable_imp_stable_r cl_stable_lr_imp_stable.

  Hypothesis cl_stable_l : cl_stability_l.
  Hypothesis cl_stable_r : cl_stability_r.

  Proposition cl_stable : cl_stability.
  Proof. auto. Qed.

  Hint Resolve cl_stable.

  Proposition cl_eq_stable_l x y : cl (cl x â€¢ y) â‰ƒ cl (x â€¢ y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Proposition cl_eq_stable_r x y : cl (x â€¢ cl y) â‰ƒ cl (x â€¢ y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Proposition cl_eq_stable x y : cl (cl x â€¢ cl y) â‰ƒ cl (x â€¢ y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Hint Immediate cl_eq_stable_l cl_eq_stable_r cl_eq_stable.


  (* Congruence *)

  Proposition cl_congruent_l x y z : x â‰¤ cl y -> z â€¢ x â‰¤ cl (z â€¢ y).
  Proof.
  intros H.
  transitivity (cl (z â€¢ cl y)).
  - apply le_cl, cl_monotone, compose_monotone; auto.
  - transitivity (cl (cl (z â€¢ y))); auto.
  Qed.

  Proposition cl_congruent_r x y z : x â‰¤ cl y -> x â€¢ z â‰¤ cl (y â€¢ z).
  Proof.
  intros H.
  transitivity (cl (cl y â€¢ z)).
  - apply le_cl, cl_monotone, compose_monotone; auto.
  - transitivity (cl (cl (y â€¢ z))); auto.
  Qed.

  Hint Resolve cl_congruent_l cl_congruent_r.

  Proposition cl_eq_congruent_l x y z : cl x â‰ƒ cl y -> cl (z â€¢ x) â‰ƒ cl (z â€¢ y).
  Proof.
  intros [H1 H2].
  assert (H3 := le_cl _ _ _ H1).
  assert (H4 := le_cl _ _ _ H2).
  split; apply cl_le; auto;
    (etransitivity ; [ | apply cl_stable_r ]);
    apply compose_monotone; auto.
  Qed.

  Proposition cl_eq_congruent_r x y z : cl x â‰ƒ cl y -> cl (x â€¢ z) â‰ƒ cl (y â€¢ z).
  Proof.
  intros [H1 H2].
  assert (H3 := le_cl _ _ _ H1).
  assert (H4 := le_cl _ _ _ H2).
  split; apply cl_le; auto;
    (etransitivity ; [ | apply cl_stable_r ]);
    apply compose_monotone; auto.
  Qed.

  Hint Resolve cl_eq_congruent_l cl_eq_congruent_r.

  Proposition cl_eq_congruent x y z t : cl x â‰ƒ cl y -> cl z â‰ƒ cl t -> cl (x â€¢ z) â‰ƒ cl (y â€¢ t).
  Proof. intros; transitivity (cl (y â€¢ z)); auto. Qed.


  (* Associativity *)

  Definition m_associativity := forall x y z, x â€¢ (y â€¢ z) = (x â€¢ y) â€¢ z.

  Definition cl_associativity_l := forall x y z, x â€¢ (y â€¢ z) â‰¤ cl ((x â€¢ y) â€¢ z).
  Definition cl_associativity_r := forall x y z, (x â€¢ y) â€¢ z â‰¤ cl (x â€¢ (y â€¢ z)).

  Lemma m_cl_associativity_l : m_associativity -> cl_associativity_l.
  Proof. intros Ha x y z; rewrite Ha; auto. Qed.

  Lemma m_cl_associativity_r : m_associativity -> cl_associativity_r.
  Proof. intros Ha x y z; rewrite Ha; auto. Qed.

  Hypothesis cl_associative_l : cl_associativity_l.
  Hypothesis cl_associative_r : cl_associativity_r.

  Hint Immediate cl_associative_l cl_associative_r.

  Proposition cl_eq_associative x y z : cl (x â€¢ (y â€¢ z)) â‰ƒ cl ((x â€¢ y) â€¢ z).
  Proof. split; auto; apply cl_le; auto. Qed.

  Hint Immediate cl_eq_associative.


  (* Tensor *)

  Definition tensor x y := (cl (x â€¢ y)).
  Infix "âŠ›" := tensor (at level 59).

  Proposition tensor_closed x y : closed (x âŠ› y).
  Proof. simpl; apply cl_idempotent. Qed.

  Instance tensor_monotone : Proper (R ==> R ==> R) tensor.
  Proof. simpl; intros ? ? ? ? ? ?; apply cl_monotone, compose_monotone; auto. Qed.

  Global Instance tensor_congruent : Proper (eqrel R ==> eqrel R ==> eqrel R) tensor.
  Proof. intros ? ? ? ? ? ?; apply cl_eq_congruent; apply cl_eq; auto. Qed.

  Proposition tensor_associative x y z : (x âŠ› y) âŠ› z â‰ƒ x âŠ› (y âŠ› z).
  Proof.
  symmetry; (etransitivity ; [ apply cl_eq_stable_r | ]).
  symmetry; (etransitivity ; [ apply cl_eq_stable_l | ]).
  symmetry; apply cl_eq_associative.
  Qed.

  Proposition tensor_associative_l x y z : x âŠ› (y âŠ› z) â‰¤ (x âŠ› y) âŠ› z.
  Proof. apply tensor_associative. Qed.

  Proposition tensor_associative_r x y z : (x âŠ› y) âŠ› z â‰¤ x âŠ› (y âŠ› z).
  Proof. apply tensor_associative. Qed.

  Hint Resolve tensor_associative_l tensor_associative_r.


  (* Adjunct *)

  Variable magicwand_l : M -> M -> M.
  Infix "âŠ¸" := magicwand_l (at level 51, right associativity).

  Hypothesis magicwand_l_adj_l : forall x y z, y â€¢ x â‰¤ z -> x â‰¤ y âŠ¸ z.
  Hypothesis magicwand_l_adj_r : forall x y z, x â‰¤ y âŠ¸ z -> y â€¢ x â‰¤ z.

  Global Instance magicwand_l_monotone : Proper (R --> R ==> R) magicwand_l.
  Proof.
  intros ? ? ? ? ? HB.
  apply magicwand_l_adj_l.
  etransitivity; [ | apply HB ].
  transitivity (x â€¢ (x âŠ¸ x0)).
  - apply compose_monotone; auto.
  - apply magicwand_l_adj_r; auto.
  Qed.

  Hint Resolve magicwand_l_monotone.

  Proposition cl_magicwand_l_1 x y : cl (x âŠ¸ cl y) â‰¤ x âŠ¸ cl y.
  Proof.
  apply magicwand_l_adj_l.
  transitivity (cl (x â€¢ (x âŠ¸ cl y))); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_magicwand_l_2 x y : cl x âŠ¸ y â‰¤ x âŠ¸ y.
  Proof. apply magicwand_l_monotone; auto; red; auto. Qed.

  Hint Immediate cl_magicwand_l_1 cl_magicwand_l_2.

  Proposition cl_magicwand_l_3 x y : x âŠ¸ cl y â‰¤ cl x âŠ¸ cl y.
  Proof.
  apply magicwand_l_adj_l.
  etransitivity; [ apply cl_stable_l | ].
  apply cl_le, magicwand_l_adj_r; auto.
  Qed.

  Hint Immediate cl_magicwand_l_3.

  Proposition magicwand_l_closed x y : closed y -> closed (x âŠ¸ y).
  Proof.
  simpl; intros ?.
  transitivity (cl (x âŠ¸ cl y)).
  - apply cl_monotone, magicwand_l_monotone; auto; red; auto.
  - transitivity (x âŠ¸ cl y); auto.
    apply magicwand_l_monotone; auto; red; auto.
  Qed.

  Hint Resolve magicwand_l_closed.

  Proposition magicwand_l_eq_1 x y : x âŠ¸ cl y â‰ƒ cl x âŠ¸ cl y.
  Proof. split; auto. Qed.

  Proposition magicwand_l_eq_2 X Y : cl (X âŠ¸ cl Y) â‰ƒ X âŠ¸ cl Y.
  Proof. split; auto. Qed.

  Hint Resolve magicwand_l_eq_1 magicwand_l_eq_2.

  Proposition magicwand_l_eq_3 x y : cl (x âŠ¸ cl y) â‰ƒ cl x âŠ¸ cl y.
  Proof. transitivity (x âŠ¸ cl y); auto. Qed.

  Hint Resolve magicwand_l_eq_3.

  Variable magicwand_r : M -> M -> M.
  Infix "âŸœ" := magicwand_r (at level 52, left associativity).

  Hypothesis magicwand_r_adj_l : forall x y z, x â€¢ y â‰¤ z -> x â‰¤ z âŸœ y.
  Hypothesis magicwand_r_adj_r : forall x y z, x â‰¤ z âŸœ y -> x â€¢ y â‰¤ z.

  Global Instance magicwand_r_monotone : Proper (R ==> R --> R) magicwand_r.
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  intros ? ? ? ? ? HB.
  apply magicwand_r_adj_l.
  transitivity ((x âŸœ x0) â€¢ x0).
  - apply compose_monotone; auto.
  - transitivity x; auto.
  Qed.

  Hint Resolve magicwand_r_monotone.

  Proposition cl_magicwand_r_1 x y : cl (cl y âŸœ x) â‰¤ cl y âŸœ x.
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  apply magicwand_r_adj_l.
  transitivity (cl ((cl y âŸœ x) â€¢ x)); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_magicwand_r_2 x y : y âŸœ cl x â‰¤ y âŸœ x.
  Proof. apply magicwand_r_monotone; auto; red; auto. Qed.

  Hint Immediate cl_magicwand_r_1 cl_magicwand_r_2.

  Proposition cl_magicwand_r_3 x y : cl y âŸœ x â‰¤ cl y âŸœ cl x.
  Proof.
  apply magicwand_r_adj_l.
  etransitivity; [ apply cl_stable_r | ].
  apply cl_le, magicwand_r_adj_r; auto.
  Qed.

  Hint Immediate cl_magicwand_r_3.

  Proposition magicwand_r_closed x y : closed y -> closed (y âŸœ x).
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  simpl; intros ?.
  transitivity (cl (cl y âŸœ x)).
  - apply cl_monotone, magicwand_r_monotone; auto; red; auto.
  - transitivity (cl y âŸœ x); auto.
    apply magicwand_r_monotone; auto; red; auto.
  Qed.

  Hint Resolve magicwand_r_closed.

  Proposition magicwand_r_eq_1 x y : cl y âŸœ x â‰ƒ cl y âŸœ cl x.
  Proof. split; auto. Qed.

  Proposition magicwand_r_eq_2 x y : cl (cl y âŸœ x) â‰ƒ cl y âŸœ x.
  Proof. split; auto. Qed.

  Hint Resolve magicwand_r_eq_1 magicwand_r_eq_2.

  Proposition magicwand_r_eq_3 x y : cl (cl y âŸœ x) â‰ƒ cl y âŸœ cl x.
  Proof. transitivity (cl y âŸœ x); auto. Qed.

  Hint Resolve magicwand_r_eq_3.

  (* Adjunction properties *)
  Proposition adjunction_l_l x y z : closed z -> y âŠ› x â‰¤ z -> x â‰¤ y âŠ¸ z.
  Proof.
  unfold tensor; intros ? H.
  apply magicwand_l_adj_l; (etransitivity; [ | apply H ]); auto.
  Qed.

  Proposition adjunction_l_r x y z : closed z -> x â‰¤ y âŠ¸ z -> y âŠ› x â‰¤ z.
  Proof.
  intros H ?.
  etransitivity; [ | apply H ].
  apply cl_monotone, magicwand_l_adj_r; auto.
  Qed.

  Hint Resolve tensor_congruent adjunction_l_l (* adjunction_l_r *).

  Proposition adjunction_r_l x y z : closed z -> x âŠ› y â‰¤ z -> x â‰¤ z âŸœ y.
  Proof.
  unfold tensor; intros ? H.
  apply magicwand_r_adj_l.
  etransitivity; [ | apply H ]; auto.
  Qed.

  Proposition adjunction_r_r x y z : closed z -> x â‰¤ z âŸœ y -> x âŠ› y â‰¤ z.
  Proof.
  intros H ?.
  etransitivity; [ | apply H ].
  apply cl_monotone, magicwand_r_adj_r; auto.
  Qed.

  Hint Resolve adjunction_r_l (* adjunction_r_r *).


  (* Unit *)

  Variable unit : M.
  Notation "ğŸ" := unit.

  Definition m_neutrality_l := forall x, ğŸ â€¢ x = x.
  Definition m_neutrality_r := forall x, x â€¢ ğŸ = x.

  Definition cl_neutrality_l_1  := forall A, A â‰¤ cl (ğŸ â€¢ A).
  Definition cl_neutrality_l_2  := forall A, ğŸ â€¢ A â‰¤ cl A.
  Definition cl_neutrality_r_1  := forall A, A â‰¤ cl (A â€¢ ğŸ).
  Definition cl_neutrality_r_2  := forall A, A â€¢ ğŸ â‰¤ cl A.

  Lemma m_cl_neutrality_l_1 : m_neutrality_l -> cl_neutrality_l_1.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_l_2 : m_neutrality_l -> cl_neutrality_l_2.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_r_1 : m_neutrality_r -> cl_neutrality_r_1.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_r_2 : m_neutrality_r -> cl_neutrality_r_2.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Hypothesis cl_neutral_l_1 : cl_neutrality_l_1.
  Hypothesis cl_neutral_l_2 : cl_neutrality_l_2.
  Hypothesis cl_neutral_r_1 : cl_neutrality_r_1.
  Hypothesis cl_neutral_r_2 : cl_neutrality_r_2.

  Hint Resolve cl_neutral_l_1 cl_neutral_l_2 cl_neutral_r_1 cl_neutral_r_2.

  Proposition cl_eq_neutral_l A : cl (ğŸ â€¢ A) â‰ƒ cl A.
  Proof. split; apply cl_le; auto. Qed.

  Proposition cl_eq_neutral_r A : cl (A â€¢ ğŸ) â‰ƒ cl A.
  Proof. split; apply cl_le; auto. Qed.

  Definition one := (cl ğŸ).
  Notation "1" := one.

  Proposition one_closed : closed 1.
  Proof. apply cl_idempotent. Qed.

(* TODO "closed_one cannot be used as a hint."
  Hint Resolve closed_one.
*)

  Proposition tensor_unit_l_1 x : x â‰¤ 1 âŠ› x.
  Proof.
  etransitivity; [ apply cl_neutral_l_1 | ].
  apply cl_monotone; apply compose_monotone; unfold one; auto.
  Qed.

  Proposition tensor_unit_l_2 x : closed x -> 1 âŠ› x â‰¤ x.
  Proof.
  intros Hc; etransitivity; [ | apply Hc ].
  apply cl_le; auto.
  etransitivity; [ apply cl_stable_l | ].
  apply cl_le; auto.
  Qed.

  Proposition tensor_unit_r_1 x : x â‰¤ x âŠ› 1.
  Proof.
  etransitivity; [ apply cl_neutral_r_1 | ].
  apply cl_monotone; apply compose_monotone; unfold one; auto.
  Qed.

  Proposition tensor_unit_r_2 x : closed x -> x âŠ› 1 â‰¤ x.
  Proof.
  intros Hc; etransitivity; [ | apply Hc ].
  apply cl_le; auto.
  etransitivity; [ apply cl_stable_r | ].
  apply cl_le; auto.
  Qed.

  Hint Resolve tensor_unit_l_1 tensor_unit_l_2 tensor_unit_r_1 tensor_unit_r_2.

  Proposition tensor_unit_l x : closed x -> 1 âŠ› x â‰ƒ x.
  Proof.
  intros H; split.
  revert H; apply tensor_unit_l_2.
  apply tensor_unit_l_1.
  Qed.

  Proposition tensor_unit_r x : closed x -> x âŠ› 1 â‰ƒ x.
  Proof.
  intros H; split.
  revert H; apply tensor_unit_r_2.
  apply tensor_unit_r_1.
  Qed.

  Hint Resolve tensor_unit_l tensor_unit_r.


  (* Commutativity *)

  Definition m_commutativity := forall x y, x â€¢ y = y â€¢ x.

  Definition cl_commutativity := forall x y, x â€¢ y â‰¤ cl (y â€¢ x).

  Lemma m_cl_commutativity : m_commutativity -> cl_commutativity.
  Proof. intros Hm x y; rewrite Hm; auto. Qed.

  Hypothesis cl_commute : cl_commutativity.

  Hint Resolve cl_commute.

  Proposition cl_eq_commute x y : cl (x â€¢ y) â‰ƒ cl (y â€¢ x).
  Proof. split; apply cl_le; auto. Qed.

  Hint Resolve cl_eq_commute.

  Proposition cl_stable_l_imp_stable_r : cl_stability_l -> cl_stability_r.
  Proof.
  intros Hl x y.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  etransitivity; [ apply Hl | ].
  apply cl_le; auto.
  Qed.

  Proposition cl_stable_r_imp_stable_l : cl_stability_r -> cl_stability_l.
  Proof.
  intros Hl x y.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  etransitivity; [ apply Hl | ].
  apply cl_le; auto.
  Qed.

  Proposition cl_stable_l_imp_stable : cl_stability_l -> cl_stability.
  Proof. auto. Qed.

  Proposition tensor_commute x y : x âŠ› y â‰¤ y âŠ› x.
  Proof. simpl; apply cl_le; auto. Qed.

  Hint Resolve tensor_commute.

  Proposition tensor_eq_commute x y : x âŠ› y â‰ƒ y âŠ› x.
  Proof. split; auto. Qed.

  Proposition cl_associative_l_imp_r : cl_associativity_l -> cl_associativity_r.
  Proof.
  intros Ha a b c.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  transitivity (cl (c â€¢ (b â€¢ a))); auto.
  apply cl_le; auto.
  etransitivity; [ apply Ha | ].
  apply cl_le; auto.
  transitivity (cl ((b â€¢ c) â€¢ a)); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_neutrality_l_imp_r_1 : cl_neutrality_l_1 -> cl_neutrality_r_1.
  Proof. intros Hn x; (etransitivity; [ apply Hn | ]); apply cl_le; auto. Qed.

  Proposition cl_neutrality_l_imp_r_2 : cl_neutrality_l_2 -> cl_neutrality_r_2.
  Proof. intros Hn x; (etransitivity; [ apply cl_commute | ]); apply cl_le; auto. Qed.

End ClosureMagma.


Section ClosureSubset.

  Context { M : Type }.
  Implicit Types A B : M -> Type.

  Definition subset A B := forall x, A x -> B x.
  Infix "âŠ†" := subset (at level 75, no associativity).

  Global Instance subset_refl : Reflexive subset := fun X a P => P.
  Global Instance subset_trans : Transitive subset := fun X Y Z P Q a H => Q a (P a H).
  Global Instance subset_preorder : PreOrder subset :=
    { PreOrder_Reflexive := subset_refl; PreOrder_Transitive := subset_trans }.

  Hint Resolve subset_refl subset_trans subset_preorder.

  Definition eqset := eqrel subset.
  Infix "â‰ƒ" := eqset (at level 75, no associativity).

  (* intersection and union *)
  Notation "A âˆ© B" := (fun z => A z * B z : Type)%type (at level 50, format "A  âˆ©  B", left associativity).
  Notation "A âˆª B" := (fun z => A z + B z : Type)%type (at level 50, format "A  âˆª  B", left associativity).

  (* singleton *)
  Notation sg := (@eq _).

  Fact sg_subset A x : A x â‰¡ sg x âŠ† A.
  Proof.
  split; intros; auto.
  intros ? []; trivial.
  Qed.


  Context { CL : @ClosureOp _ subset }.
  Notation closed := (fun x => cl x âŠ† x).

  (* Intersection and Union *)
  Definition glb A B := A âˆ© B.
  Definition lub A B := cl (A âˆª B).
  Infix "âŠ“" := glb (at level 50, no associativity).
  Infix "âŠ”" := lub (at level 50, no associativity).

  Proposition glb_closed A B : closed A -> closed B -> closed (A âŠ“ B).
  Proof.
  unfold glb; simpl; intros HA HB x Hx; split;
    [ apply HA | apply HB ]; revert x Hx;
    apply (@cl_monotone _ _ CL) ; red; tauto.
  Qed.

  Proposition lub_closed A B : closed (A âŠ” B).
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition lub_out A B C : closed C -> A âŠ† C -> B âŠ† C -> A âŠ” B âŠ† C.
  Proof.
  simpl; intros H1 H2 H3.
  apply subset_trans with (2 := H1), cl_monotone.
  intros ? [ ]; auto.
  Qed.

  Proposition glb_in A B C : C âŠ† A -> C âŠ† B -> C âŠ† A âŠ“ B.
  Proof. simpl; split; auto. Qed.

  Proposition glb_out_l A B  : A âŠ“ B âŠ† A.
  Proof. unfold glb; simpl; red; tauto. Qed.

  Proposition glb_out_r A B  : A âŠ“ B âŠ† B.
  Proof. unfold glb; simpl; red; tauto. Qed.

  Proposition lub_in_l A B   : A âŠ† A âŠ” B.
  Proof. apply subset_trans with (2 := cl_increase _); red; tauto. Qed.

  Proposition lub_in_r A B   : B âŠ† A âŠ” B.
  Proof. apply subset_trans with (2 := cl_increase _); red; tauto. Qed.

  Proposition glb_comm A B : A âŠ“ B â‰ƒ B âŠ“ A.
  Proof. unfold glb; split; apply glb_in; red; tauto. Qed.

  Definition top : M -> Type := (fun _ : M => True).
  Definition zero := (cl ((fun _ : M => False) : M -> Type)).

  Proposition top_closed : closed top.
  Proof. unfold top; simpl; intros; red; auto. Qed.

  Proposition zero_closed : closed zero.
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition top_greatest A : A âŠ† top.
  Proof. unfold top; simpl; red; tauto. Qed.

  Proposition zero_least A : closed A -> zero âŠ† A.
  Proof. intro H; apply subset_trans with (2 := H), cl_monotone; red; tauto. Qed.

  Fact mglb_closed l : Forall_Type closed l -> closed (fold_right (fun x y => x âˆ© y) top l).
  Proof. induction 1; [ apply top_closed | apply glb_closed ]; auto. Qed.

End ClosureSubset.


Section SubsetMagma.

  Context { M : Type }.
  Implicit Types A B : M -> Type.

  Variable compose : M -> M -> M.

(*
  Infix "â€¢" := compose (at level 45, no associativity).
*)
  Infix "âŠ†" := (@subset M) (at level 75, no associativity).
  Infix "â‰ƒ" := (@eqset M) (at level 75, no associativity).
  Notation sg := (@eq _).
  Hint Resolve subset_preorder.

  (* Composition lifted to subsets *)
  Inductive composes A B : M -> Type :=
    In_composes : forall a b, A a -> B b -> composes A B (compose a b).

  Infix "âˆ˜" := composes (at level 50, no associativity).

  Global Instance composes_monotone : Proper (subset ==> subset ==> subset) composes.
  Proof. intros X1 Y1 H1 X2 Y2 H2 x [a b Ha Hb]; constructor; auto. Qed.

  Global Instance composes_compat : Proper (eqset ==> eqset ==> eqset) composes.
  Proof. intros X1 Y1 [H1 H2] X2 Y2 [H3 H4]; split; apply composes_monotone; auto. Qed.


  (* Adjunct *)
  Definition magicwand_l A B c := A âˆ˜ sg c âŠ† B.
  Infix "âŠ¸" := magicwand_l (at level 51, right associativity).

  Proposition magicwand_l_adj_l A B C : B âˆ˜ A âŠ† C -> A âŠ† B âŠ¸ C.
  Proof.
  intros H x Hx y Hy.
  apply H; revert Hy; apply composes_monotone; [ reflexivity | ].
  apply sg_subset; assumption.
  Qed.

  Proposition magicwand_l_adj_r A B C : A âŠ† B âŠ¸ C -> B âˆ˜ A âŠ† C.
  Proof.
  intros H x Hx.
  destruct Hx as [ b a Hb Ha ].
  apply (H _ Ha).
  constructor; auto.
  Qed.

  Definition magicwand_r B A c := sg c âˆ˜ A âŠ† B.
  Infix "âŸœ" := magicwand_r (at level 52, left associativity).

  Proposition magicwand_r_adj_l A B C : A âˆ˜ B âŠ† C -> A âŠ† C âŸœ B.
  Proof.
  intros H x Hx y Hy.
  apply H; revert Hy; apply composes_monotone; [ | reflexivity ].
  apply sg_subset; auto.
  Qed.

  Proposition magicwand_r_adj_r A B C : A âŠ† C âŸœ B -> A âˆ˜ B âŠ† C.
  Proof.
  intros H x Hx.
  destruct Hx as [ a b Ha Hb ].
  apply (H _ Ha).
  constructor; auto.
  Qed.

  Hint Resolve magicwand_l_adj_l magicwand_l_adj_r magicwand_r_adj_l magicwand_r_adj_r.


  (* Distributivity *)
  Context { CL : @ClosureOp _ (@subset M) }.
  Notation closed := (fun A => cl A âŠ† A).
  Infix "âŠ›" := (tensor composes) (at level 59).
  Notation "0" := (@zero _ CL).
  Infix "âŠ”" := (@lub _ CL) (at level 50, no associativity).

  Hypothesis cl_stable_l : cl_stability_l composes.
  Hypothesis cl_stable_r : cl_stability_r composes.

  Hint Resolve (@cl_idempotent _ _ CL) cl_stable_l cl_stable_r (cl_stable _ cl_stable_l cl_stable_r).
  Hint Resolve (@magicwand_l_closed _ _ _ CL _ _ cl_stable_r magicwand_l magicwand_l_adj_l magicwand_l_adj_r).
  Hint Resolve (@magicwand_r_closed _ _ _ CL _ _ cl_stable_l magicwand_r magicwand_r_adj_l magicwand_r_adj_r).

  Proposition tensor_zero_distrib_l A : 0 âŠ› A âŠ† 0.
  Proof.
  unfold zero; apply (@adjunction_r_r _ _ _ CL _ magicwand_r); auto.
  apply zero_least; auto.
  Qed.

  Proposition tensor_zero_distrib_r A : A âŠ› zero âŠ† zero.
  Proof.
  unfold zero; apply (@adjunction_l_r _ _ _ CL _ magicwand_l); auto.
  apply zero_least; auto.
  Qed.

  Hint Immediate tensor_zero_distrib_l tensor_zero_distrib_r.

  Proposition tensor_lub_distrib_l A B C : (A âŠ” B) âŠ› C âŠ† (A âŠ› C) âŠ” (B âŠ› C).
  Proof.
  unfold lub; apply (@adjunction_r_r _ _ _ CL _ magicwand_r), lub_out; auto;
   eapply (@adjunction_r_l _ _ _ CL composes); auto;
   intros ? ? ; apply (@cl_increase _ _ CL); auto.
  Qed.

  Proposition tensor_lub_distrib_r A B C : C âŠ› (A âŠ” B) âŠ† (C âŠ› A) âŠ” (C âŠ› B).
  Proof.
  unfold lub; apply (@adjunction_l_r _ _ _ CL _ magicwand_l), lub_out; auto;
    eapply (@adjunction_l_l _ _ _ CL composes); auto;
    intros ? ? ; apply (@cl_increase _ _ CL); auto.
  Qed.

(* TODO try to move at magma level ??? *)

  (* Exponentials *)
  (* J := { x | x âˆˆ 1 /\ x âˆˆ x âŠ› x } *)

  Variable unit : M.
  Notation "1" := (@one _ _ CL (sg unit)).
  Notation "A âˆ© B" := (fun z => A z * B z : Type)%type (at level 50, format "A  âˆ©  B", left associativity).
  Infix "âŠ“" := glb (at level 50, no associativity).

  Hypothesis cl_neutral_l_1 : cl_neutrality_l_1 composes (sg unit).
  Hypothesis cl_neutral_l_2 : cl_neutrality_l_2 composes (sg unit).
  Hypothesis cl_neutral_r_1 : cl_neutrality_r_1 composes (sg unit).
  Hypothesis cl_neutral_r_2 : cl_neutrality_r_2 composes (sg unit).

  Hint Resolve cl_neutral_l_1 cl_neutral_l_2 cl_neutral_r_1 cl_neutral_r_2.

  Let J x := (1 x * (sg x âŠ› sg x) x)%type.

  Let In_J : forall x, 1 x -> (sg x âŠ› sg x) x -> J x.
  Proof. split; auto. Qed.

  Let J_inv x : J x -> 1 x * (sg x âŠ› sg x) x.
  Proof. auto. Qed.

  Proposition J_inc_unit : J âŠ† 1.
  Proof. intros ? ?; apply J_inv; auto. Qed.

  Variable K : M -> Type.

  Definition sub_monoid_hyp_1 := ((cl K) unit).
  Definition sub_monoid_hyp_2 := (K âˆ˜ K âŠ† K).
  Definition sub_J_hyp := (K âŠ† J).

  Hypothesis sub_monoid_1 : sub_monoid_hyp_1.
  Hypothesis sub_monoid_2 : sub_monoid_hyp_2.
  Hypothesis sub_J : sub_J_hyp.

  Proposition K_inc_unit : K âŠ† 1.
  Proof. transitivity J; trivial; apply J_inc_unit. Qed.

  Proposition K_compose A B : (K âˆ© A) âˆ˜ (K âˆ© B) âŠ† K âˆ© (A âˆ˜ B).
  Proof.
  intros x Hx.
  split; [ apply sub_monoid_2 | ];
    revert Hx; apply composes_monotone; intros z [Hz1 Hz2]; assumption.
  Qed.

  Definition bang A := cl (K âˆ© A).

  Notation "â— A" := (bang A) (at level 40, no associativity).

  Fact store_inc_unit A : â— A âŠ† 1.
  Proof.
  transitivity (cl K).
  - apply cl_monotone; red; tauto.
  - apply cl_le, K_inc_unit; auto.
  Qed.

  Hint Resolve store_inc_unit.

  Proposition store_closed A : closed (â—A).
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition store_dec A : closed A -> â—A âŠ† A.
  Proof.
  intros HA; simpl.
  transitivity (cl A); trivial.
  apply cl_monotone.
  apply glb_out_r.
  Qed.

  Global Instance store_monotone : Proper (subset ==> subset) bang.
  Proof. intros ? ? ?; apply cl_monotone; intros ? []; split; auto. Qed.

  Hint Resolve store_monotone.

  Global Instance store_congruence : Proper (eqset ==> eqset) bang.
  Proof. intros ? ? [? ?]; split; auto. Qed.

  Proposition store_der A B : closed B -> â—A âŠ† B -> â—A âŠ† â—B.
  Proof.
  unfold bang; intros H1 H2; apply cl_monotone; intros x []; split; auto.
  apply H2; auto.
  apply (@cl_increase _ subset); auto.
  Qed.

  Proposition store_unit_1 : 1 âŠ† â—top.
  Proof.
  unfold top; apply cl_le; auto.
  intros ? []; apply (@cl_monotone _ subset _ K); auto; red; auto.
  Qed.

  Hint Resolve J_inc_unit.

  Proposition store_unit_2 : â—top âŠ† 1.
  Proof.
  apply cl_le; trivial.
  transitivity J; auto.
  intros ? []; auto.
  Qed.

  Hint Resolve store_unit_1 store_unit_2.

  Proposition store_unit : 1 â‰ƒ â—top.
  Proof. split; auto. Qed.

  Hint Resolve store_unit.

  Proposition store_comp A B : closed A -> closed B -> â—A âŠ› â—B â‰ƒ â—(A âŠ“ B).
  Proof.
  intros HA HB; split.
  - apply subset_trans with (cl ((K âŠ“ A) âˆ˜ (K âŠ“ B))).
    + apply cl_le; trivial; apply cl_stable; auto.
    + apply cl_monotone.
      intros x H.
      split; [ | split ].
      * apply sub_monoid_2; revert H; apply composes_monotone; intros z [Hz _]; assumption.
      * refine (@tensor_unit_r_2 _ subset _ _ composes _ (sg unit) _ _ _ _ _); auto.
        apply (@cl_increase _ subset).
        revert H; apply composes_monotone; intros z [Hz1 Hz2]; try assumption.
        apply K_inc_unit; auto.
      * refine (@tensor_unit_l_2 _ subset _ _ composes _ (sg unit) _ _ _ _ _); auto.
        apply (@cl_increase _ subset).
        revert H; apply composes_monotone; intros z [Hz1 Hz2]; try assumption.
        apply K_inc_unit; auto.
  - apply cl_le; trivial.
    intros x (H1 & H2 & H3).
    apply (@cl_monotone _ subset) with (sg x âˆ˜ sg x).
    + apply composes_monotone; intros z Heq; subst; apply (@cl_increase _ subset); auto.
    + apply sub_J in H1; destruct H1; trivial.
  Qed.

  Definition ltensor := fold_right (fun x y => x âŠ› y) 1.
  Definition lcap := fold_right (fun x y => x âˆ© y) (@top M).

  Hint Resolve mglb_closed.

  Proposition ltensor_store l : Forall_Type closed l -> ltensor (map bang l) â‰ƒ â—(lcap l).
  Proof.
  unfold ltensor, lcap.
  induction 1; simpl; auto.
  transitivity (â— x âŠ› â—(lcap l)).
  - apply tensor_congruent; auto; [ apply composes_monotone | reflexivity ].
  - apply store_comp; unfold lcap; auto.
  Qed.

  Proposition store_compose_idem A : closed A -> â—A âŠ† â—A âŠ› â—A.
  Proof.
  intros HA.
  transitivity (â—(A âˆ© A)).
  - apply store_der. 
    + apply glb_closed; trivial.
    + transitivity A; red; auto.
      apply store_dec; trivial.
  - apply store_comp; trivial.
  Qed.

End SubsetMagma.

