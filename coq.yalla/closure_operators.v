(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*         CeCILL v2 FREE SOFTWARE LICENSE AGREEMENT          *)
(**************************************************************)

(*   Adapted by Olivier Laurent [**]                          *)
(*                                                            *)
(*                              [**] Affiliation LIP -- CNRS  *)


Require Import CRelationClasses CMorphisms.
Require Import List_Type.

Set Implicit Arguments.

(* equivalence at Type *)
Notation "X â‰¡ Y" := ((X->Y)*(Y->X))%type (at level 80, format "X  â‰¡  Y", no associativity).

Section ClosurePreOrder.

  Context { M : Type }.

  (* TODO equivalence generated by a PreOrder *)
  Definition eqrel (S : M -> M -> Type) x y := ((S x y) * (S y x))%type.

  Global Instance eqrel_refl S (POS : PreOrder S) : Reflexive (eqrel S) :=
    fun x => (@PreOrder_Reflexive _ _ POS x, @PreOrder_Reflexive _ _ POS x).
  Global Instance eqrel_sym S (POS : PreOrder S) : Symmetric (eqrel S) :=
    fun _ _ H => match H with (H1, H2) => (H2, H1) end.
  Global Instance eqrel_trans S (POS : PreOrder S) : Transitive (eqrel S) :=
    fun _ _ _ P Q =>
    match P, Q with (P1,P2), (Q1,Q2) => (@PreOrder_Transitive _ _ POS _ _ _ P1 Q1,
                                         @PreOrder_Transitive _ _ POS _ _ _ Q2 P2) end.
  Global Instance eqrel_equiv S (POS : PreOrder S) : Equivalence (eqrel S) :=
    { Equivalence_Reflexive := eqrel_refl POS;
      Equivalence_Symmetric := eqrel_sym POS;
      Equivalence_Transitive := eqrel_trans POS }.

  Global Instance eq_eqrel S (POS : PreOrder S) : Proper (eq ==> eqrel S) id.
  Proof. split; subst; reflexivity. Qed.

  Context { R : M -> M -> Type }.
  Variable PO : PreOrder R.

  Infix "â‰¤" := R (at level 75, no associativity).
  Infix "â‰ƒ" := (eqrel R) (at level 75, no associativity).

  Hint Resolve (eqrel_refl PO) (eqrel_trans PO).
  Hint Immediate (eqrel_sym PO).

  Class ClosureOp := {
    cl          : M -> M;
    cl_increase : forall x, x â‰¤ cl x;
    cl_monotone : forall x y, x â‰¤ y -> cl x â‰¤ cl y;
    cl_idempotent : forall x, cl (cl x) â‰¤ cl x }.

  Context { CL : ClosureOp }.

  Proposition cl_le x y : x â‰¤ cl y -> cl x â‰¤ cl y.
  Proof.
  intros; transitivity (cl (cl y)); [ apply cl_monotone; assumption | apply cl_idempotent ].
  Qed.

  Proposition le_cl x y : cl x â‰¤ cl y -> x â‰¤ cl y.
  Proof. intros ; transitivity (cl x); [ apply cl_increase | assumption ]. Qed.

  Fact cl_eq A B : A â‰ƒ B -> cl A â‰ƒ cl B.
  Proof. intros []; split; apply cl_monotone; assumption. Qed.

  Notation closed := (fun x => cl x â‰¤ x).

  Fact cl_closed x y : closed y -> x â‰¤ y -> cl x â‰¤ y.
  Proof. intros; transitivity (cl y); [ apply cl_monotone | ] ; assumption. Qed.

End ClosurePreOrder.


Section ClosureMagma.

  Context { M : Type } { R : M -> M -> Type }.
  Variable PO : PreOrder R.
  Context { CL : @ClosureOp _ R }.

  Hint Resolve (@PreOrder_Reflexive _ _ PO).
  Hint Resolve (@cl_increase _ _ CL) (@cl_monotone _ _ CL) (@cl_idempotent _ _ CL).

  Variable compose : M -> M -> M.

  Infix "â‰¤" := R (at level 75, no associativity).
  Infix "â‰ƒ" := (eqrel R) (at level 75, no associativity).
  Infix "â€¢" := compose (at level 45, no associativity).
  Notation closed := (fun x => cl x â‰¤ x).

  Hypothesis compose_monotone : Proper (R ==> R ==> R) compose.

  Hint Resolve compose_monotone.


  (* Stability *)

  Definition cl_stability   := forall x y, cl x â€¢ cl y â‰¤ cl (x â€¢ y).
  Definition cl_stability_l := forall x y, cl x â€¢    y â‰¤ cl (x â€¢ y).
  Definition cl_stability_r := forall x y,    x â€¢ cl y â‰¤ cl (x â€¢ y).

  Proposition cl_stable_imp_stable_l : cl_stability -> cl_stability_l.
  Proof.
  intros Hs x y.
  transitivity (cl x â€¢ cl y); auto.
  apply compose_monotone; auto.
  Qed.

  Proposition cl_stable_imp_stable_r : cl_stability -> cl_stability_r.
  Proof.
  intros Hs x y.
  transitivity (cl x â€¢ cl y); auto.
  apply compose_monotone; auto.
  Qed.

  Proposition cl_stable_lr_imp_stable : cl_stability_l -> cl_stability_r -> cl_stability.
  Proof.
  intros Hsl Hsr x y.
  etransitivity; [ | apply cl_idempotent ].
  transitivity (cl (cl x â€¢ y)); auto.
  Qed.

  Hint Resolve cl_stable_imp_stable_l cl_stable_imp_stable_r cl_stable_lr_imp_stable.

  Hypothesis cl_stable_l : cl_stability_l.
  Hypothesis cl_stable_r : cl_stability_r.

  Proposition cl_stable : cl_stability.
  Proof. auto. Qed.

  Hint Resolve cl_stable.

  Proposition cl_eq_stable_l x y : cl (cl x â€¢ y) â‰ƒ cl (x â€¢ y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Proposition cl_eq_stable_r x y : cl (x â€¢ cl y) â‰ƒ cl (x â€¢ y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Proposition cl_eq_stable x y : cl (cl x â€¢ cl y) â‰ƒ cl (x â€¢ y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Hint Immediate cl_eq_stable_l cl_eq_stable_r cl_eq_stable.


  (* Congruence *)

  Proposition cl_congruent_l x y z : x â‰¤ cl y -> z â€¢ x â‰¤ cl (z â€¢ y).
  Proof.
  intros H.
  transitivity (cl (z â€¢ cl y)).
  - apply le_cl, cl_monotone, compose_monotone; auto.
  - transitivity (cl (cl (z â€¢ y))); auto.
  Qed.

  Proposition cl_congruent_r x y z : x â‰¤ cl y -> x â€¢ z â‰¤ cl (y â€¢ z).
  Proof.
  intros H.
  transitivity (cl (cl y â€¢ z)).
  - apply le_cl, cl_monotone, compose_monotone; auto.
  - transitivity (cl (cl (y â€¢ z))); auto.
  Qed.

  Hint Resolve cl_congruent_l cl_congruent_r.

  Proposition cl_eq_congruent_l x y z : cl x â‰ƒ cl y -> cl (z â€¢ x) â‰ƒ cl (z â€¢ y).
  Proof.
  intros [H1 H2].
  assert (H3 := le_cl _ _ _ H1).
  assert (H4 := le_cl _ _ _ H2).
  split; apply cl_le; auto;
    (etransitivity ; [ | apply cl_stable_r ]);
    apply compose_monotone; auto.
  Qed.

  Proposition cl_eq_congruent_r x y z : cl x â‰ƒ cl y -> cl (x â€¢ z) â‰ƒ cl (y â€¢ z).
  Proof.
  intros [H1 H2].
  assert (H3 := le_cl _ _ _ H1).
  assert (H4 := le_cl _ _ _ H2).
  split; apply cl_le; auto;
    (etransitivity ; [ | apply cl_stable_r ]);
    apply compose_monotone; auto.
  Qed.

  Hint Resolve cl_eq_congruent_l cl_eq_congruent_r.

  Proposition cl_eq_congruent x y z t : cl x â‰ƒ cl y -> cl z â‰ƒ cl t -> cl (x â€¢ z) â‰ƒ cl (y â€¢ t).
  Proof. intros; transitivity (cl (y â€¢ z)); auto. Qed.


  (* Associativity *)

  Definition m_associativity_rel Rel := forall x y z, Rel (x â€¢ (y â€¢ z)) ((x â€¢ y) â€¢ z).
  Definition m_associativity := m_associativity_rel eq.

  Definition cl_associativity_l := forall x y z, x â€¢ (y â€¢ z) â‰¤ cl ((x â€¢ y) â€¢ z).
  Definition cl_associativity_r := forall x y z, (x â€¢ y) â€¢ z â‰¤ cl (x â€¢ (y â€¢ z)).

  Lemma m_cl_associativity_l : m_associativity -> cl_associativity_l.
  Proof. intros Ha x y z; rewrite Ha; auto. Qed.

  Lemma m_cl_associativity_r : m_associativity -> cl_associativity_r.
  Proof. intros Ha x y z; rewrite Ha; auto. Qed.

  Hypothesis cl_associative_l : cl_associativity_l.
  Hypothesis cl_associative_r : cl_associativity_r.

  Hint Immediate cl_associative_l cl_associative_r.

  Proposition cl_eq_associative x y z : cl (x â€¢ (y â€¢ z)) â‰ƒ cl ((x â€¢ y) â€¢ z).
  Proof. split; auto; apply cl_le; auto. Qed.

  Hint Immediate cl_eq_associative.


  (* Tensor *)

  Definition tensor x y := (cl (x â€¢ y)).
  Infix "âŠ›" := tensor (at level 59).

  Proposition tensor_closed x y : closed (x âŠ› y).
  Proof. simpl; apply cl_idempotent. Qed.

  Instance tensor_monotone : Proper (R ==> R ==> R) tensor.
  Proof. simpl; intros ? ? ? ? ? ?; apply cl_monotone, compose_monotone; auto. Qed.

  Global Instance tensor_congruent : Proper (eqrel R ==> eqrel R ==> eqrel R) tensor.
  Proof. intros ? ? ? ? ? ?; apply cl_eq_congruent; apply cl_eq; auto. Qed.

  Proposition tensor_associative x y z : (x âŠ› y) âŠ› z â‰ƒ x âŠ› (y âŠ› z).
  Proof.
  symmetry; (etransitivity ; [ apply cl_eq_stable_r | ]).
  symmetry; (etransitivity ; [ apply cl_eq_stable_l | ]).
  symmetry; apply cl_eq_associative.
  Qed.

  Proposition tensor_associative_l x y z : x âŠ› (y âŠ› z) â‰¤ (x âŠ› y) âŠ› z.
  Proof. apply tensor_associative. Qed.

  Proposition tensor_associative_r x y z : (x âŠ› y) âŠ› z â‰¤ x âŠ› (y âŠ› z).
  Proof. apply tensor_associative. Qed.

  Hint Resolve tensor_associative_l tensor_associative_r.


  (* Adjunct *)

  Variable magicwand_l : M -> M -> M.
  Infix "âŠ¸" := magicwand_l (at level 51, right associativity).

  Hypothesis magicwand_l_adj_l : forall x y z, y â€¢ x â‰¤ z -> x â‰¤ y âŠ¸ z.
  Hypothesis magicwand_l_adj_r : forall x y z, x â‰¤ y âŠ¸ z -> y â€¢ x â‰¤ z.

  Global Instance magicwand_l_monotone : Proper (R --> R ==> R) magicwand_l.
  Proof.
  intros ? ? ? ? ? HB.
  apply magicwand_l_adj_l.
  etransitivity; [ | apply HB ].
  transitivity (x â€¢ (x âŠ¸ x0)).
  - apply compose_monotone; auto.
  - apply magicwand_l_adj_r; auto.
  Qed.

  Hint Resolve magicwand_l_monotone.

  Proposition cl_magicwand_l_1 x y : cl (x âŠ¸ cl y) â‰¤ x âŠ¸ cl y.
  Proof.
  apply magicwand_l_adj_l.
  transitivity (cl (x â€¢ (x âŠ¸ cl y))); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_magicwand_l_2 x y : cl x âŠ¸ y â‰¤ x âŠ¸ y.
  Proof. apply magicwand_l_monotone; auto; red; auto. Qed.

  Hint Immediate cl_magicwand_l_1 cl_magicwand_l_2.

  Proposition cl_magicwand_l_3 x y : x âŠ¸ cl y â‰¤ cl x âŠ¸ cl y.
  Proof.
  apply magicwand_l_adj_l.
  etransitivity; [ apply cl_stable_l | ].
  apply cl_le, magicwand_l_adj_r; auto.
  Qed.

  Hint Immediate cl_magicwand_l_3.

  Proposition magicwand_l_closed x y : closed y -> closed (x âŠ¸ y).
  Proof.
  simpl; intros ?.
  transitivity (cl (x âŠ¸ cl y)).
  - apply cl_monotone, magicwand_l_monotone; auto; red; auto.
  - transitivity (x âŠ¸ cl y); auto.
    apply magicwand_l_monotone; auto; red; auto.
  Qed.

  Hint Resolve magicwand_l_closed.

  Proposition magicwand_l_eq_1 x y : x âŠ¸ cl y â‰ƒ cl x âŠ¸ cl y.
  Proof. split; auto. Qed.

  Proposition magicwand_l_eq_2 X Y : cl (X âŠ¸ cl Y) â‰ƒ X âŠ¸ cl Y.
  Proof. split; auto. Qed.

  Hint Resolve magicwand_l_eq_1 magicwand_l_eq_2.

  Proposition magicwand_l_eq_3 x y : cl (x âŠ¸ cl y) â‰ƒ cl x âŠ¸ cl y.
  Proof. transitivity (x âŠ¸ cl y); auto. Qed.

  Hint Resolve magicwand_l_eq_3.

  Variable magicwand_r : M -> M -> M.
  Infix "âŸœ" := magicwand_r (at level 52, left associativity).

  Hypothesis magicwand_r_adj_l : forall x y z, x â€¢ y â‰¤ z -> x â‰¤ z âŸœ y.
  Hypothesis magicwand_r_adj_r : forall x y z, x â‰¤ z âŸœ y -> x â€¢ y â‰¤ z.

  Global Instance magicwand_r_monotone : Proper (R ==> R --> R) magicwand_r.
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  intros ? ? ? ? ? HB.
  apply magicwand_r_adj_l.
  transitivity ((x âŸœ x0) â€¢ x0).
  - apply compose_monotone; auto.
  - transitivity x; auto.
  Qed.

  Hint Resolve magicwand_r_monotone.

  Proposition cl_magicwand_r_1 x y : cl (cl y âŸœ x) â‰¤ cl y âŸœ x.
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  apply magicwand_r_adj_l.
  transitivity (cl ((cl y âŸœ x) â€¢ x)); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_magicwand_r_2 x y : y âŸœ cl x â‰¤ y âŸœ x.
  Proof. apply magicwand_r_monotone; auto; red; auto. Qed.

  Hint Immediate cl_magicwand_r_1 cl_magicwand_r_2.

  Proposition cl_magicwand_r_3 x y : cl y âŸœ x â‰¤ cl y âŸœ cl x.
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  apply magicwand_r_adj_l.
  etransitivity; [ apply cl_stable_r | ].
  apply cl_le, magicwand_r_adj_r; auto.
  Qed.

  Hint Immediate cl_magicwand_r_3.

  Proposition magicwand_r_closed x y : closed y -> closed (y âŸœ x).
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  simpl; intros ?.
  transitivity (cl (cl y âŸœ x)).
  - apply cl_monotone, magicwand_r_monotone; auto; red; auto.
  - transitivity (cl y âŸœ x); auto.
    apply magicwand_r_monotone; auto; red; auto.
  Qed.

  Hint Resolve magicwand_r_closed.

  Proposition magicwand_r_eq_1 x y : cl y âŸœ x â‰ƒ cl y âŸœ cl x.
  Proof. clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r; split; auto. Qed.

  Proposition magicwand_r_eq_2 x y : cl (cl y âŸœ x) â‰ƒ cl y âŸœ x.
  Proof. split; auto. Qed.

  Hint Resolve magicwand_r_eq_1 magicwand_r_eq_2.

  Proposition magicwand_r_eq_3 x y : cl (cl y âŸœ x) â‰ƒ cl y âŸœ cl x.
  Proof. transitivity (cl y âŸœ x); auto. Qed.

  Hint Resolve magicwand_r_eq_3.

  (* Adjunction properties *)
  Proposition adjunction_l_l x y z : closed z -> y âŠ› x â‰¤ z -> x â‰¤ y âŠ¸ z.
  Proof.
  unfold tensor; intros ? H.
  apply magicwand_l_adj_l; (etransitivity; [ | apply H ]); auto.
  Qed.

  Proposition adjunction_l_r x y z : closed z -> x â‰¤ y âŠ¸ z -> y âŠ› x â‰¤ z.
  Proof.
  intros H ?.
  etransitivity; [ | apply H ].
  apply cl_monotone, magicwand_l_adj_r; auto.
  Qed.

  Hint Resolve tensor_congruent adjunction_l_l (* adjunction_l_r *).

  Proposition adjunction_r_l x y z : closed z -> x âŠ› y â‰¤ z -> x â‰¤ z âŸœ y.
  Proof.
  unfold tensor; intros ? H.
  apply magicwand_r_adj_l.
  etransitivity; [ | apply H ]; auto.
  Qed.

  Proposition adjunction_r_r x y z : closed z -> x â‰¤ z âŸœ y -> x âŠ› y â‰¤ z.
  Proof.
  intros H ?.
  etransitivity; [ | apply H ].
  apply cl_monotone, magicwand_r_adj_r; auto.
  Qed.

  Hint Resolve adjunction_r_l (* adjunction_r_r *).


  (* Unit *)

  Variable unit : M.
  Notation "ðŸ" := unit.

  Definition m_neutrality_l_rel Rel := forall x, Rel (ðŸ â€¢ x) x.
  Definition m_neutrality_r_rel Rel := forall x, Rel (x â€¢ ðŸ) x.
  Definition m_neutrality_l := m_neutrality_l_rel eq.
  Definition m_neutrality_r := m_neutrality_r_rel eq.

  Definition cl_neutrality_l_1  := forall A, A â‰¤ cl (ðŸ â€¢ A).
  Definition cl_neutrality_l_2  := forall A, ðŸ â€¢ A â‰¤ cl A.
  Definition cl_neutrality_r_1  := forall A, A â‰¤ cl (A â€¢ ðŸ).
  Definition cl_neutrality_r_2  := forall A, A â€¢ ðŸ â‰¤ cl A.

  Lemma m_cl_neutrality_l_1 : m_neutrality_l -> cl_neutrality_l_1.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_l_2 : m_neutrality_l -> cl_neutrality_l_2.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_r_1 : m_neutrality_r -> cl_neutrality_r_1.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_r_2 : m_neutrality_r -> cl_neutrality_r_2.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Hypothesis cl_neutral_l_1 : cl_neutrality_l_1.
  Hypothesis cl_neutral_l_2 : cl_neutrality_l_2.
  Hypothesis cl_neutral_r_1 : cl_neutrality_r_1.
  Hypothesis cl_neutral_r_2 : cl_neutrality_r_2.

  Hint Resolve cl_neutral_l_1 cl_neutral_l_2 cl_neutral_r_1 cl_neutral_r_2.

  Proposition cl_eq_neutral_l A : cl (ðŸ â€¢ A) â‰ƒ cl A.
  Proof. split; apply cl_le; auto. Qed.

  Proposition cl_eq_neutral_r A : cl (A â€¢ ðŸ) â‰ƒ cl A.
  Proof. split; apply cl_le; auto. Qed.

  Definition one := (cl ðŸ).
  Notation "1" := one.

  Proposition one_closed : closed 1.
  Proof. apply cl_idempotent. Qed.

(* TODO "one_closed cannot be used as a hint."
  Hint Resolve one_closed.
*)

  Proposition tensor_unit_l_1 x : x â‰¤ 1 âŠ› x.
  Proof.
  etransitivity; [ apply cl_neutral_l_1 | ].
  apply cl_monotone; apply compose_monotone; unfold one; auto.
  Qed.

  Proposition tensor_unit_l_2 x : closed x -> 1 âŠ› x â‰¤ x.
  Proof.
  intros Hc; etransitivity; [ | apply Hc ].
  apply cl_le; auto.
  etransitivity; [ apply cl_stable_l | ].
  apply cl_le; auto.
  Qed.

  Proposition tensor_unit_r_1 x : x â‰¤ x âŠ› 1.
  Proof.
  etransitivity; [ apply cl_neutral_r_1 | ].
  apply cl_monotone; apply compose_monotone; unfold one; auto.
  Qed.

  Proposition tensor_unit_r_2 x : closed x -> x âŠ› 1 â‰¤ x.
  Proof.
  intros Hc; etransitivity; [ | apply Hc ].
  apply cl_le; auto.
  etransitivity; [ apply cl_stable_r | ].
  apply cl_le; auto.
  Qed.

  Hint Resolve tensor_unit_l_1 tensor_unit_l_2 tensor_unit_r_1 tensor_unit_r_2.

  Proposition tensor_unit_l x : closed x -> 1 âŠ› x â‰ƒ x.
  Proof.
  intros H; split.
  revert H; apply tensor_unit_l_2.
  apply tensor_unit_l_1.
  Qed.

  Proposition tensor_unit_r x : closed x -> x âŠ› 1 â‰ƒ x.
  Proof.
  intros H; split.
  revert H; apply tensor_unit_r_2.
  apply tensor_unit_r_1.
  Qed.

  Hint Resolve tensor_unit_l tensor_unit_r.


  (* Commutativity *)

  Definition m_commutativity := forall x y, x â€¢ y = y â€¢ x.

  Definition cl_commutativity := forall x y, x â€¢ y â‰¤ cl (y â€¢ x).

  Lemma m_cl_commutativity : m_commutativity -> cl_commutativity.
  Proof. intros Hm x y; rewrite Hm; auto. Qed.

  Hypothesis cl_commute : cl_commutativity.

  Hint Resolve cl_commute.

  Proposition cl_eq_commute x y : cl (x â€¢ y) â‰ƒ cl (y â€¢ x).
  Proof. split; apply cl_le; auto. Qed.

  Hint Resolve cl_eq_commute.

  Proposition cl_stable_l_imp_stable_r : cl_stability_l -> cl_stability_r.
  Proof.
  intros Hl x y.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  etransitivity; [ apply Hl | ].
  apply cl_le; auto.
  Qed.

  Proposition cl_stable_r_imp_stable_l : cl_stability_r -> cl_stability_l.
  Proof.
  intros Hl x y.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  etransitivity; [ apply Hl | ].
  apply cl_le; auto.
  Qed.

  Proposition cl_stable_l_imp_stable : cl_stability_l -> cl_stability.
  Proof. auto. Qed.

  Proposition tensor_commute x y : x âŠ› y â‰¤ y âŠ› x.
  Proof. simpl; apply cl_le; auto. Qed.

  Hint Resolve tensor_commute.

  Proposition tensor_eq_commute x y : x âŠ› y â‰ƒ y âŠ› x.
  Proof. split; auto. Qed.

  Proposition cl_associative_l_imp_r : cl_associativity_l -> cl_associativity_r.
  Proof.
  intros Ha a b c.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  transitivity (cl (c â€¢ (b â€¢ a))); auto.
  apply cl_le; auto.
  etransitivity; [ apply Ha | ].
  apply cl_le; auto.
  transitivity (cl ((b â€¢ c) â€¢ a)); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_neutrality_l_imp_r_1 : cl_neutrality_l_1 -> cl_neutrality_r_1.
  Proof. intros Hn x; (etransitivity; [ apply Hn | ]); apply cl_le; auto. Qed.

  Proposition cl_neutrality_l_imp_r_2 : cl_neutrality_l_2 -> cl_neutrality_r_2.
  Proof. intros Hn x; (etransitivity; [ apply cl_commute | ]); apply cl_le; auto. Qed.


  (* Axioms for Greatest Lower Bound *)

  Variable mglb : M -> M -> M.
  Infix "âŠ“" := mglb (at level 50, no associativity).
  Hypothesis mglb_in : forall x y z, x â‰¤ y -> x â‰¤ z -> x â‰¤ y âŠ“ z.
  Hypothesis mglb_out_l : forall x y, x âŠ“ y â‰¤ x.
  Hypothesis mglb_out_r : forall x y, x âŠ“ y â‰¤ y.

  Hint Resolve mglb_in mglb_out_l mglb_out_r.

  Proposition mglb_monotone x1 x2 y1 y2 : x1 â‰¤ y1 -> x2 â‰¤ y2 -> x1 âŠ“ x2 â‰¤ y1 âŠ“ y2.
  Proof. intros H1 H2; apply mglb_in; (etransitivity; [ | eassumption ]); auto. Qed.

  Hint Resolve mglb_monotone.

  Proposition mglb_comm x y : x âŠ“ y â‰ƒ y âŠ“ x.
  Proof. split; apply mglb_in; auto. Qed.

  Proposition mglb_closed x y : closed x -> closed y -> closed (x âŠ“ y).
  Proof.
  intros Hcx Hcy; apply mglb_in.
  - etransitivity; [ | apply Hcx ]; apply cl_monotone; auto.
  - etransitivity; [ | apply Hcy ]; apply cl_monotone; auto.
  Qed.

  Variable mtop : M.
  Hypothesis mtop_greatest : forall x, x â‰¤ mtop.

  Proposition mtop_closed : closed mtop.
  Proof. apply mtop_greatest. Qed.

  Notation lmglb := (fold_right mglb mtop).

  Fact lmglb_closed l : Forall_Type closed l -> closed (lmglb l).
  Proof. induction 1; [ apply mtop_closed | apply mglb_closed ]; auto. Qed.


  (* Exponentials *)

  Variable k : M.

  Definition sub_monoid_hyp_1 := ðŸ â‰¤ cl k.
  Definition sub_monoid_hyp_2 := k â€¢ k â‰¤ k.
  Definition sub_J_hyp_1 := k â‰¤ 1.
  Definition sub_J_hyp_2 := forall x, x â‰¤ k -> x â‰¤ x âŠ› x.

  Hypothesis sub_monoid_1 : sub_monoid_hyp_1.
  Hypothesis sub_monoid_2 : sub_monoid_hyp_2.
  Hypothesis sub_J_1 : sub_J_hyp_1.
  Hypothesis sub_J_2 : sub_J_hyp_2.

  Proposition k_compose x y : (k âŠ“ x) â€¢ (k âŠ“ y) â‰¤ k âŠ“ (x â€¢ y).
  Proof.
  apply mglb_in.
  - etransitivity ; [ | apply sub_monoid_2 ].
    apply compose_monotone; auto.
  - apply compose_monotone; auto.
  Qed.

  Definition bang A := cl (k âŠ“ A).

  Notation "â— A" := (bang A) (at level 40, no associativity).

  Fact store_inc_unit A : â— A â‰¤ 1.
  Proof. transitivity (cl k); [ apply cl_monotone | apply cl_le]; auto. Qed.

  Hint Resolve store_inc_unit.

  Proposition store_closed x : closed (â—x).
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition store_dec x : closed x -> â—x â‰¤ x.
  Proof. intros ?; transitivity (cl x); try apply cl_monotone; auto. Qed.

  Global Instance store_monotone : Proper (R ==> R) bang.
  Proof. intros ? ? ?; apply cl_monotone; auto. Qed.

  Hint Resolve store_monotone.

  Global Instance store_congruence : Proper (eqrel R ==> eqrel R) bang.
  Proof. intros ? ? [? ?]; split; auto. Qed.

  Proposition store_der x y : closed y -> â—x â‰¤ y -> â—x â‰¤ â—y.
  Proof.
  unfold bang; intros H1 H2; apply cl_monotone; apply mglb_in; auto.
  etransitivity; [ | apply H2 ]; auto.
  Qed.

  Proposition store_unit_1 : 1 â‰¤ â—mtop.
  Proof. apply cl_le; auto ; (etransitivity; [ apply sub_monoid_1 | ]); apply cl_monotone; auto. Qed.

  Proposition store_unit_2 : â—mtop â‰¤ 1.
  Proof. apply cl_le; trivial; transitivity k; auto. Qed.

  Hint Resolve store_unit_1 store_unit_2.

  Proposition store_unit : 1 â‰ƒ â—mtop.
  Proof. split; auto. Qed.

  Hint Resolve store_unit.

  Proposition store_comp_2 x y : â—(x âŠ“ y) â‰¤ â—x âŠ› â—y.
  Proof.
  apply cl_le; trivial.
  transitivity (cl ((k âŠ“ (x âŠ“ y)) â€¢ (k âŠ“ (x âŠ“ y)))).
  - apply sub_J_2; auto.
  - apply cl_monotone.
    apply compose_monotone; (etransitivity; [ | apply cl_increase ]); auto.
  Qed.

  Proposition store_comp x y : closed x -> closed y -> â—x âŠ› â—y â‰ƒ â—(x âŠ“ y).
  Proof.
  intros Hcx Hcy; split.
  - transitivity (cl ((k âŠ“ x) â€¢ (k âŠ“ y))).
    + apply cl_le; trivial; apply cl_stable; auto.
    + apply cl_monotone.
      apply mglb_in; [ | apply mglb_in ].
      * etransitivity; [ | apply sub_monoid_2].
        apply compose_monotone; auto.
      * etransitivity; [ | apply tensor_unit_r_2 ]; auto.
        etransitivity; [ | apply cl_increase ].
        apply compose_monotone; auto.
        etransitivity; [ apply mglb_out_l | apply sub_J_1 ].
      * etransitivity; [ | apply tensor_unit_l_2 ]; auto.
        etransitivity; [ | apply cl_increase ].
        apply compose_monotone; auto.
        etransitivity; [ apply mglb_out_l | apply sub_J_1 ].
  - apply store_comp_2.
  Qed.

  Proposition store_compose_idem x : â—x â‰¤ â—x âŠ› â—x.
  Proof. transitivity (â—(x âŠ“ x)); [ apply store_monotone | apply store_comp_2 ]; auto. Qed.


  Notation ltensor := (fold_right (fun x y => x âŠ› y) 1).

  Proposition ltensor_store l : Forall_Type closed l -> ltensor (map bang l) â‰ƒ â—(lmglb l).
  Proof.
  unfold ltensor, lmglb.
  induction 1; simpl; auto.
  transitivity (â— x âŠ› â—(lmglb l)).
  - apply tensor_congruent; auto; reflexivity.
  - apply store_comp; auto.
    apply lmglb_closed; auto.
  Qed.

  Notation lcompose := (fold_right compose unit).

  Fact lcompose_nil : lcompose nil = unit.
  Proof. auto. Qed.

  Fact lcompose_cons f l : lcompose (f :: l) = f â€¢ lcompose l.
  Proof. auto. Qed.

  Fact lcompose_store l : cl (lcompose (map (fun x => â—(cl x)) l)) â‰ƒ â— (lmglb (map cl l)).
  Proof.
  induction l; split; simpl; auto; try (destruct IHl as [IHl1 IHl2]).
  - apply cl_le; auto.
    transitivity (â—(cl a) â€¢ cl(â— (lmglb (map cl l)))).
    + apply compose_monotone; auto.
      etransitivity; [ | etransitivity; [apply IHl1 | ] ]; auto; apply cl_increase.
    + etransitivity; [ apply cl_stable_r | ]; simpl.
      etransitivity; [ apply store_comp | ]; auto.
      apply lmglb_closed; auto.
      clear IHl1 IHl2; induction l; simpl; auto.
  - transitivity (cl(â—(cl a) â€¢ (â— (lmglb (map cl l))))).
    + etransitivity; [ | apply store_comp_2 ]; auto.
    + apply cl_le; auto.
  Qed.

End ClosureMagma.


Section ClosureSubsetMagma.

  Context { M : Type }.
  Implicit Types A B : M -> Type.

  Definition subset A B := forall x, A x -> B x.

  Global Instance subset_refl : Reflexive subset := fun X a P => P.
  Global Instance subset_trans : Transitive subset := fun X Y Z P Q a H => Q a (P a H).
  Global Instance subset_preorder : PreOrder subset :=
    { PreOrder_Reflexive := subset_refl; PreOrder_Transitive := subset_trans }.

  Hint Resolve subset_refl subset_trans subset_preorder.

  Definition eqset := eqrel subset.

  Infix "âŠ†" := subset (at level 75, no associativity).
  Infix "â‰ƒ" := eqset (at level 75, no associativity).
  Infix "âˆ©" := (fun A B z => A z * B z : Type)%type (at level 50, left associativity).
  Infix "âˆª" := (fun A B z => A z + B z : Type)%type (at level 50, left associativity).
  Notation sg := (@eq _ : _ -> _ -> Type).

  Fact sg_subset A x : A x â‰¡ sg x âŠ† A.
  Proof. split; intros; auto; intros ? []; trivial. Qed.

  Context { CL : @ClosureOp _ subset }.
  Notation closed := (fun x => cl x âŠ† x).

  (* Intersection and Union *)
  Definition glb A B := A âˆ© B.
  Definition lub A B := cl (A âˆª B).
  Infix "âŠ“" := glb (at level 50, no associativity).
  Infix "âŠ”" := lub (at level 50, no associativity).

  Proposition glb_in A B C  : C âŠ† A -> C âŠ† B -> C âŠ† A âŠ“ B.
  Proof. simpl; split; auto. Qed.

  Proposition glb_out_l A B : A âŠ“ B âŠ† A.
  Proof. unfold glb; simpl; red; tauto. Qed.

  Proposition glb_out_r A B : A âŠ“ B âŠ† B.
  Proof. unfold glb; simpl; red; tauto. Qed.

  Proposition lub_closed A B : closed (A âŠ” B).
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition lub_out A B C : closed C -> A âŠ† C -> B âŠ† C -> A âŠ” B âŠ† C.
  Proof.
  simpl; intros H1 H2 H3.
  apply subset_trans with (2 := H1), cl_monotone.
  intros ? [ ]; auto.
  Qed.

  Proposition lub_in_l A B  : A âŠ† A âŠ” B.
  Proof. apply subset_trans with (2 := cl_increase _); red; tauto. Qed.

  Proposition lub_in_r A B  : B âŠ† A âŠ” B.
  Proof. apply subset_trans with (2 := cl_increase _); red; tauto. Qed.

  Definition top := (fun _ : M => True).

  Proposition top_greatest A : A âŠ† top.
  Proof. intros x Hx; apply I. Qed.

  Definition zero := (cl ((fun _ : M => False) : M -> Type)).
  Notation "0" := zero.

  Proposition zero_closed : closed zero.
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition zero_least A : closed A -> zero âŠ† A.
  Proof. intro H; apply subset_trans with (2 := H), cl_monotone; red; tauto. Qed.


  Variable compose : M -> M -> M.
  Variable unit : M.

  (* Composition lifted to subsets *)
  Inductive composes A B : M -> Type :=
    In_composes : forall a b, A a -> B b -> composes A B (compose a b).

  Infix "âˆ˜" := composes (at level 50, no associativity).

  Global Instance composes_monotone : Proper (subset ==> subset ==> subset) composes.
  Proof. intros X1 Y1 H1 X2 Y2 H2 x [a b Ha Hb]; constructor; auto. Qed.

  Global Instance composes_compat : Proper (eqset ==> eqset ==> eqset) composes.
  Proof. intros X1 Y1 [H1 H2] X2 Y2 [H3 H4]; split; apply composes_monotone; auto. Qed.

  Lemma m_pwr_associativity : m_associativity compose -> m_associativity_rel composes eqset.
  Proof.
  intros Hass x y z; split; intros a Ha.
  - inversion Ha; inversion X0.
    rewrite Hass.
    repeat constructor; assumption.
  - inversion Ha; inversion X.
    rewrite <- Hass.
    repeat constructor; assumption.
  Qed.

  Lemma m_pwr_neutrality_l : m_neutrality_l compose unit -> m_neutrality_l_rel composes (sg unit) eqset.
  Proof.
  intros Hc x; split; intros a Ha.
  - inversion Ha; subst.
    rewrite Hc; assumption.
  - rewrite <- Hc.
    constructor; auto.
  Qed.

  Lemma m_pwr_neutrality_r : m_neutrality_r compose unit -> m_neutrality_r_rel composes (sg unit) eqset.
  Proof.
  intros Hc x; split; intros a Ha.
  - inversion Ha; subst.
    rewrite Hc; assumption.
  - rewrite <- Hc.
    constructor; auto.
  Qed.

  Lemma m_pwr_cl_neutrality_l_2 : m_neutrality_l compose unit -> cl_neutrality_l_2 composes (sg unit).
  Proof.
  intros Hc x.
  etransitivity; [ | apply cl_increase ].
  intros z Hz; inversion Hz; subst; rewrite Hc; auto.
  Qed.

  Lemma m_pwr_cl_neutrality_r_2 : m_neutrality_r compose unit -> cl_neutrality_r_2 composes (sg unit).
  Proof.
  intros Hc x.
  etransitivity; [ | apply cl_increase ].
  intros z Hz; inversion Hz; subst; rewrite Hc; auto.
  Qed.


  (* Adjunct *)
  Definition magicwand_l A B c := A âˆ˜ sg c âŠ† B.
  Infix "âŠ¸" := magicwand_l (at level 51, right associativity).

  Proposition magicwand_l_adj_l A B C : B âˆ˜ A âŠ† C -> A âŠ† B âŠ¸ C.
  Proof.
  intros H x Hx y Hy.
  apply H; revert Hy; apply composes_monotone; [ reflexivity | ].
  apply sg_subset; assumption.
  Qed.

  Proposition magicwand_l_adj_r A B C : A âŠ† B âŠ¸ C -> B âˆ˜ A âŠ† C.
  Proof.
  intros H x Hx.
  destruct Hx as [ b a Hb Ha ].
  apply (H _ Ha).
  constructor; auto.
  Qed.

  Definition magicwand_r B A c := sg c âˆ˜ A âŠ† B.
  Infix "âŸœ" := magicwand_r (at level 52, left associativity).

  Proposition magicwand_r_adj_l A B C : A âˆ˜ B âŠ† C -> A âŠ† C âŸœ B.
  Proof.
  intros H x Hx y Hy.
  apply H; revert Hy; apply composes_monotone; [ | reflexivity ].
  apply sg_subset; auto.
  Qed.

  Proposition magicwand_r_adj_r A B C : A âŠ† C âŸœ B -> A âˆ˜ B âŠ† C.
  Proof.
  intros H x Hx.
  destruct Hx as [ a b Ha Hb ].
  apply (H _ Ha).
  constructor; auto.
  Qed.

  Hint Resolve magicwand_l_adj_l magicwand_l_adj_r magicwand_r_adj_l magicwand_r_adj_r.


  (* Distributivity *)
  Infix "âŠ›" := (tensor composes) (at level 59).
  Notation "1" := (@one _ _ CL (sg unit)).

  Hypothesis cl_stable_l : cl_stability_l composes.
  Hypothesis cl_stable_r : cl_stability_r composes.

  Hint Resolve (@cl_idempotent _ _ CL) cl_stable_l cl_stable_r (cl_stable _ cl_stable_l cl_stable_r).
  Hint Resolve (@magicwand_l_closed _ _ _ CL _ _ cl_stable_r magicwand_l magicwand_l_adj_l magicwand_l_adj_r).
  Hint Resolve (@magicwand_r_closed _ _ _ CL _ _ cl_stable_l magicwand_r magicwand_r_adj_l magicwand_r_adj_r).

  Proposition tensor_zero_distrib_l A : 0 âŠ› A âŠ† 0.
  Proof. unfold zero; apply (@adjunction_r_r _ _ _ CL _ magicwand_r); auto; apply zero_least; auto. Qed.

  Proposition tensor_zero_distrib_r A : A âŠ› zero âŠ† zero.
  Proof. unfold zero; apply (@adjunction_l_r _ _ _ CL _ magicwand_l); auto; apply zero_least; auto. Qed.

  Hint Immediate tensor_zero_distrib_l tensor_zero_distrib_r.

  Proposition tensor_lub_distrib_l A B C : (A âŠ” B) âŠ› C âŠ† (A âŠ› C) âŠ” (B âŠ› C).
  Proof.
  unfold lub; apply (@adjunction_r_r _ _ _ CL _ magicwand_r), lub_out; auto;
   eapply (@adjunction_r_l _ _ _ CL composes); auto;
   intros ? ? ; apply (@cl_increase _ _ CL); auto.
  Qed.

  Proposition tensor_lub_distrib_r A B C : C âŠ› (A âŠ” B) âŠ† (C âŠ› A) âŠ” (C âŠ› B).
  Proof.
  unfold lub; apply (@adjunction_l_r _ _ _ CL _ magicwand_l), lub_out; auto;
    eapply (@adjunction_l_l _ _ _ CL composes); auto;
    intros ? ? ; apply (@cl_increase _ _ CL); auto.
  Qed.


  (* Exponentials *)
  (* J := { x | x âˆˆ 1 /\ x âˆˆ x âŠ› x } *)

  Let J x := (1 x * (sg x âŠ› sg x) x)%type.

  Let J_inv x : J x -> 1 x * (sg x âŠ› sg x) x.
  Proof. auto. Qed.

  Variable K : M -> Type.

  Definition pwr_sub_monoid_hyp_1 := ((cl K) unit).
  Definition pwr_sub_monoid_hyp_2 := (K âˆ˜ K âŠ† K).
  Definition pwr_sub_J_hyp := (K âŠ† J).

  Proposition sub_monoid_1 : pwr_sub_monoid_hyp_1 -> @sub_monoid_hyp_1 _ subset CL (sg unit) K.
  Proof. intros Hpwr x Hx; rewrite <- Hx; assumption. Qed.

  Proposition sub_monoid_2 : pwr_sub_monoid_hyp_2 -> @sub_monoid_hyp_2 _ subset composes K.
  Proof. auto. Qed.

  Proposition sub_J_1 : pwr_sub_J_hyp -> @sub_J_hyp_1 _ subset CL (sg unit) K.
  Proof. intros Hpwr x Hx; apply J_inv; auto. Qed.

  Proposition sub_J_2 : pwr_sub_J_hyp -> @sub_J_hyp_2 _ subset CL composes K.
  Proof.
  intros Hpwr X HX x Hx.
  assert ((sg x âŠ› sg x) x) as Hsg by (apply J_inv, Hpwr; auto).
  assert ((sg x âˆ˜ sg x) âŠ† X âˆ˜ X) as Hc by (intros z Hz; inversion Hz; subst; constructor; auto).
  apply (@cl_monotone _ subset CL) in Hc; apply Hc; auto.
  Qed.

End ClosureSubsetMagma.


Module SetNotations.

  Infix "âŠ†" := subset (at level 75, no associativity).
  Infix "â‰ƒ" := eqset (at level 75, no associativity).
  Infix "âˆ©" := (fun A B z => A z * B z : Type)%type (at level 50, left associativity).
  Infix "âˆª" := (fun A B z => A z + B z : Type)%type (at level 50, left associativity).
  Notation sg := (@eq _ : _ -> _ -> Type).

End SetNotations.

