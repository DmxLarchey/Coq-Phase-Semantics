(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*         CeCILL v2 FREE SOFTWARE LICENSE AGREEMENT          *)
(**************************************************************)

(*   Adapted by Olivier Laurent [**]                          *)
(*                                                            *)
(*                              [**] Affiliation LIP -- CNRS  *)


Require Import CRelationClasses CMorphisms.
Require Import List_Type.

Set Implicit Arguments.

(* equivalence at Type *)
Notation "X ≡ Y" := ((X->Y)*(Y->X))%type (at level 80, format "X  ≡  Y", no associativity).

Section ClosurePreOrder.

  Context { M : Type }.

  (* TODO equivalence generated by a PreOrder *)
  Definition eqrel (S : M -> M -> Type) x y := ((S x y) * (S y x))%type.

  Global Instance eqrel_refl S (POS : PreOrder S) : Reflexive (eqrel S) :=
    fun x => (@PreOrder_Reflexive _ _ POS x, @PreOrder_Reflexive _ _ POS x).
  Global Instance eqrel_sym S (POS : PreOrder S) : Symmetric (eqrel S) :=
    fun _ _ H => match H with (H1, H2) => (H2, H1) end.
  Global Instance eqrel_trans S (POS : PreOrder S) : Transitive (eqrel S) :=
    fun _ _ _ P Q =>
    match P, Q with (P1,P2), (Q1,Q2) => (@PreOrder_Transitive _ _ POS _ _ _ P1 Q1,
                                         @PreOrder_Transitive _ _ POS _ _ _ Q2 P2) end.
  Global Instance eqrel_equiv S (POS : PreOrder S) : Equivalence (eqrel S) :=
    { Equivalence_Reflexive := eqrel_refl POS;
      Equivalence_Symmetric := eqrel_sym POS;
      Equivalence_Transitive := eqrel_trans POS }.

  Global Instance eq_eqrel S (POS : PreOrder S) : Proper (eq ==> eqrel S) id.
  Proof. split; subst; reflexivity. Qed.

  Context { R : M -> M -> Type }.
  Variable PO : PreOrder R.

  Infix "≤" := R (at level 75, no associativity).
  Infix "≃" := (eqrel R) (at level 75, no associativity).

  Hint Resolve (eqrel_refl PO) (eqrel_trans PO).
  Hint Immediate (eqrel_sym PO).

  Class ClosureOp := {
    cl          : M -> M;
    cl_increase : forall x, x ≤ cl x;
    cl_monotone : forall x y, x ≤ y -> cl x ≤ cl y;
    cl_idempotent : forall x, cl (cl x) ≤ cl x }.

  Context { CL : ClosureOp }.

  Proposition cl_le x y : x ≤ cl y -> cl x ≤ cl y.
  Proof.
  intros; transitivity (cl (cl y)); [ apply cl_monotone; assumption | apply cl_idempotent ].
  Qed.

  Proposition le_cl x y : cl x ≤ cl y -> x ≤ cl y.
  Proof. intros ; transitivity (cl x); [ apply cl_increase | assumption ]. Qed.

  Fact cl_eq A B : A ≃ B -> cl A ≃ cl B.
  Proof. intros []; split; apply cl_monotone; assumption. Qed.

  Notation closed := (fun x => cl x ≤ x).

  Fact cl_closed x y : closed y -> x ≤ y -> cl x ≤ y.
  Proof. intros; transitivity (cl y); [ apply cl_monotone | ] ; assumption. Qed.

End ClosurePreOrder.


Section ClosureMagma.

  Context { M : Type } { R : M -> M -> Type }.
  Variable PO : PreOrder R.
  Context { CL : @ClosureOp _ R }.

  Hint Resolve (@PreOrder_Reflexive _ _ PO).
  Hint Resolve (@cl_increase _ _ CL) (@cl_monotone _ _ CL) (@cl_idempotent _ _ CL).

  Variable compose : M -> M -> M.

  Infix "≤" := R (at level 75, no associativity).
  Infix "≃" := (eqrel R) (at level 75, no associativity).
  Infix "•" := compose (at level 45, no associativity).
  Notation closed := (fun x => cl x ≤ x).

  Hypothesis compose_monotone : Proper (R ==> R ==> R) compose.

  Hint Resolve compose_monotone.


  (* Stability *)

  Definition cl_stability   := forall x y, cl x • cl y ≤ cl (x • y).
  Definition cl_stability_l := forall x y, cl x •    y ≤ cl (x • y).
  Definition cl_stability_r := forall x y,    x • cl y ≤ cl (x • y).

  Proposition cl_stable_imp_stable_l : cl_stability -> cl_stability_l.
  Proof.
  intros Hs x y.
  transitivity (cl x • cl y); auto.
  apply compose_monotone; auto.
  Qed.

  Proposition cl_stable_imp_stable_r : cl_stability -> cl_stability_r.
  Proof.
  intros Hs x y.
  transitivity (cl x • cl y); auto.
  apply compose_monotone; auto.
  Qed.

  Proposition cl_stable_lr_imp_stable : cl_stability_l -> cl_stability_r -> cl_stability.
  Proof.
  intros Hsl Hsr x y.
  etransitivity; [ | apply cl_idempotent ].
  transitivity (cl (cl x • y)); auto.
  Qed.

  Hint Resolve cl_stable_imp_stable_l cl_stable_imp_stable_r cl_stable_lr_imp_stable.

  Hypothesis cl_stable_l : cl_stability_l.
  Hypothesis cl_stable_r : cl_stability_r.

  Proposition cl_stable : cl_stability.
  Proof. auto. Qed.

  Hint Resolve cl_stable.

  Proposition cl_eq_stable_l x y : cl (cl x • y) ≃ cl (x • y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Proposition cl_eq_stable_r x y : cl (x • cl y) ≃ cl (x • y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Proposition cl_eq_stable x y : cl (cl x • cl y) ≃ cl (x • y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Hint Immediate cl_eq_stable_l cl_eq_stable_r cl_eq_stable.


  (* Congruence *)

  Proposition cl_congruent_l x y z : x ≤ cl y -> z • x ≤ cl (z • y).
  Proof.
  intros H.
  transitivity (cl (z • cl y)).
  - apply le_cl, cl_monotone, compose_monotone; auto.
  - transitivity (cl (cl (z • y))); auto.
  Qed.

  Proposition cl_congruent_r x y z : x ≤ cl y -> x • z ≤ cl (y • z).
  Proof.
  intros H.
  transitivity (cl (cl y • z)).
  - apply le_cl, cl_monotone, compose_monotone; auto.
  - transitivity (cl (cl (y • z))); auto.
  Qed.

  Hint Resolve cl_congruent_l cl_congruent_r.

  Proposition cl_eq_congruent_l x y z : cl x ≃ cl y -> cl (z • x) ≃ cl (z • y).
  Proof.
  intros [H1 H2].
  assert (H3 := le_cl _ _ _ H1).
  assert (H4 := le_cl _ _ _ H2).
  split; apply cl_le; auto;
    (etransitivity ; [ | apply cl_stable_r ]);
    apply compose_monotone; auto.
  Qed.

  Proposition cl_eq_congruent_r x y z : cl x ≃ cl y -> cl (x • z) ≃ cl (y • z).
  Proof.
  intros [H1 H2].
  assert (H3 := le_cl _ _ _ H1).
  assert (H4 := le_cl _ _ _ H2).
  split; apply cl_le; auto;
    (etransitivity ; [ | apply cl_stable_r ]);
    apply compose_monotone; auto.
  Qed.

  Hint Resolve cl_eq_congruent_l cl_eq_congruent_r.

  Proposition cl_eq_congruent x y z t : cl x ≃ cl y -> cl z ≃ cl t -> cl (x • z) ≃ cl (y • t).
  Proof. intros; transitivity (cl (y • z)); auto. Qed.


  (* Associativity *)

  Definition m_associativity_rel Rel := forall x y z, Rel (x • (y • z)) ((x • y) • z).
  Definition m_associativity := m_associativity_rel eq.

  Definition cl_associativity_l := forall x y z, x • (y • z) ≤ cl ((x • y) • z).
  Definition cl_associativity_r := forall x y z, (x • y) • z ≤ cl (x • (y • z)).

  Lemma m_cl_associativity_l : m_associativity -> cl_associativity_l.
  Proof. intros Ha x y z; rewrite Ha; auto. Qed.

  Lemma m_cl_associativity_r : m_associativity -> cl_associativity_r.
  Proof. intros Ha x y z; rewrite Ha; auto. Qed.

  Hypothesis cl_associative_l : cl_associativity_l.
  Hypothesis cl_associative_r : cl_associativity_r.

  Hint Immediate cl_associative_l cl_associative_r.

  Proposition cl_eq_associative x y z : cl (x • (y • z)) ≃ cl ((x • y) • z).
  Proof. split; auto; apply cl_le; auto. Qed.

  Hint Immediate cl_eq_associative.


  (* Tensor *)

  Definition tensor x y := (cl (x • y)).
  Infix "⊛" := tensor (at level 59).

  Proposition tensor_closed x y : closed (x ⊛ y).
  Proof. simpl; apply cl_idempotent. Qed.

  Instance tensor_monotone : Proper (R ==> R ==> R) tensor.
  Proof. simpl; intros ? ? ? ? ? ?; apply cl_monotone, compose_monotone; auto. Qed.

  Global Instance tensor_congruent : Proper (eqrel R ==> eqrel R ==> eqrel R) tensor.
  Proof. intros ? ? ? ? ? ?; apply cl_eq_congruent; apply cl_eq; auto. Qed.

  Proposition tensor_associative x y z : (x ⊛ y) ⊛ z ≃ x ⊛ (y ⊛ z).
  Proof.
  symmetry; (etransitivity ; [ apply cl_eq_stable_r | ]).
  symmetry; (etransitivity ; [ apply cl_eq_stable_l | ]).
  symmetry; apply cl_eq_associative.
  Qed.

  Proposition tensor_associative_l x y z : x ⊛ (y ⊛ z) ≤ (x ⊛ y) ⊛ z.
  Proof. apply tensor_associative. Qed.

  Proposition tensor_associative_r x y z : (x ⊛ y) ⊛ z ≤ x ⊛ (y ⊛ z).
  Proof. apply tensor_associative. Qed.

  Hint Resolve tensor_associative_l tensor_associative_r.


  (* Adjunct *)

  Variable magicwand_l : M -> M -> M.
  Infix "⊸" := magicwand_l (at level 51, right associativity).

  Hypothesis magicwand_l_adj_l : forall x y z, y • x ≤ z -> x ≤ y ⊸ z.
  Hypothesis magicwand_l_adj_r : forall x y z, x ≤ y ⊸ z -> y • x ≤ z.

  Global Instance magicwand_l_monotone : Proper (R --> R ==> R) magicwand_l.
  Proof.
  intros ? ? ? ? ? HB.
  apply magicwand_l_adj_l.
  etransitivity; [ | apply HB ].
  transitivity (x • (x ⊸ x0)).
  - apply compose_monotone; auto.
  - apply magicwand_l_adj_r; auto.
  Qed.

  Hint Resolve magicwand_l_monotone.

  Proposition cl_magicwand_l_1 x y : cl (x ⊸ cl y) ≤ x ⊸ cl y.
  Proof.
  apply magicwand_l_adj_l.
  transitivity (cl (x • (x ⊸ cl y))); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_magicwand_l_2 x y : cl x ⊸ y ≤ x ⊸ y.
  Proof. apply magicwand_l_monotone; auto; red; auto. Qed.

  Hint Immediate cl_magicwand_l_1 cl_magicwand_l_2.

  Proposition cl_magicwand_l_3 x y : x ⊸ cl y ≤ cl x ⊸ cl y.
  Proof.
  apply magicwand_l_adj_l.
  etransitivity; [ apply cl_stable_l | ].
  apply cl_le, magicwand_l_adj_r; auto.
  Qed.

  Hint Immediate cl_magicwand_l_3.

  Proposition magicwand_l_closed x y : closed y -> closed (x ⊸ y).
  Proof.
  simpl; intros ?.
  transitivity (cl (x ⊸ cl y)).
  - apply cl_monotone, magicwand_l_monotone; auto; red; auto.
  - transitivity (x ⊸ cl y); auto.
    apply magicwand_l_monotone; auto; red; auto.
  Qed.

  Hint Resolve magicwand_l_closed.

  Proposition magicwand_l_eq_1 x y : x ⊸ cl y ≃ cl x ⊸ cl y.
  Proof. split; auto. Qed.

  Proposition magicwand_l_eq_2 X Y : cl (X ⊸ cl Y) ≃ X ⊸ cl Y.
  Proof. split; auto. Qed.

  Hint Resolve magicwand_l_eq_1 magicwand_l_eq_2.

  Proposition magicwand_l_eq_3 x y : cl (x ⊸ cl y) ≃ cl x ⊸ cl y.
  Proof. transitivity (x ⊸ cl y); auto. Qed.

  Hint Resolve magicwand_l_eq_3.

  Variable magicwand_r : M -> M -> M.
  Infix "⟜" := magicwand_r (at level 52, left associativity).

  Hypothesis magicwand_r_adj_l : forall x y z, x • y ≤ z -> x ≤ z ⟜ y.
  Hypothesis magicwand_r_adj_r : forall x y z, x ≤ z ⟜ y -> x • y ≤ z.

  Global Instance magicwand_r_monotone : Proper (R ==> R --> R) magicwand_r.
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  intros ? ? ? ? ? HB.
  apply magicwand_r_adj_l.
  transitivity ((x ⟜ x0) • x0).
  - apply compose_monotone; auto.
  - transitivity x; auto.
  Qed.

  Hint Resolve magicwand_r_monotone.

  Proposition cl_magicwand_r_1 x y : cl (cl y ⟜ x) ≤ cl y ⟜ x.
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  apply magicwand_r_adj_l.
  transitivity (cl ((cl y ⟜ x) • x)); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_magicwand_r_2 x y : y ⟜ cl x ≤ y ⟜ x.
  Proof. apply magicwand_r_monotone; auto; red; auto. Qed.

  Hint Immediate cl_magicwand_r_1 cl_magicwand_r_2.

  Proposition cl_magicwand_r_3 x y : cl y ⟜ x ≤ cl y ⟜ cl x.
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  apply magicwand_r_adj_l.
  etransitivity; [ apply cl_stable_r | ].
  apply cl_le, magicwand_r_adj_r; auto.
  Qed.

  Hint Immediate cl_magicwand_r_3.

  Proposition magicwand_r_closed x y : closed y -> closed (y ⟜ x).
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  simpl; intros ?.
  transitivity (cl (cl y ⟜ x)).
  - apply cl_monotone, magicwand_r_monotone; auto; red; auto.
  - transitivity (cl y ⟜ x); auto.
    apply magicwand_r_monotone; auto; red; auto.
  Qed.

  Hint Resolve magicwand_r_closed.

  Proposition magicwand_r_eq_1 x y : cl y ⟜ x ≃ cl y ⟜ cl x.
  Proof. clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r; split; auto. Qed.

  Proposition magicwand_r_eq_2 x y : cl (cl y ⟜ x) ≃ cl y ⟜ x.
  Proof. split; auto. Qed.

  Hint Resolve magicwand_r_eq_1 magicwand_r_eq_2.

  Proposition magicwand_r_eq_3 x y : cl (cl y ⟜ x) ≃ cl y ⟜ cl x.
  Proof. transitivity (cl y ⟜ x); auto. Qed.

  Hint Resolve magicwand_r_eq_3.

  (* Adjunction properties *)
  Proposition adjunction_l_l x y z : closed z -> y ⊛ x ≤ z -> x ≤ y ⊸ z.
  Proof.
  unfold tensor; intros ? H.
  apply magicwand_l_adj_l; (etransitivity; [ | apply H ]); auto.
  Qed.

  Proposition adjunction_l_r x y z : closed z -> x ≤ y ⊸ z -> y ⊛ x ≤ z.
  Proof.
  intros H ?.
  etransitivity; [ | apply H ].
  apply cl_monotone, magicwand_l_adj_r; auto.
  Qed.

  Hint Resolve tensor_congruent adjunction_l_l (* adjunction_l_r *).

  Proposition adjunction_r_l x y z : closed z -> x ⊛ y ≤ z -> x ≤ z ⟜ y.
  Proof.
  unfold tensor; intros ? H.
  apply magicwand_r_adj_l.
  etransitivity; [ | apply H ]; auto.
  Qed.

  Proposition adjunction_r_r x y z : closed z -> x ≤ z ⟜ y -> x ⊛ y ≤ z.
  Proof.
  intros H ?.
  etransitivity; [ | apply H ].
  apply cl_monotone, magicwand_r_adj_r; auto.
  Qed.

  Hint Resolve adjunction_r_l (* adjunction_r_r *).


  (* Unit *)

  Variable unit : M.
  Notation "𝟏" := unit.

  Definition m_neutrality_l_rel Rel := forall x, Rel (𝟏 • x) x.
  Definition m_neutrality_r_rel Rel := forall x, Rel (x • 𝟏) x.
  Definition m_neutrality_l := m_neutrality_l_rel eq.
  Definition m_neutrality_r := m_neutrality_r_rel eq.

  Definition cl_neutrality_l_1  := forall A, A ≤ cl (𝟏 • A).
  Definition cl_neutrality_l_2  := forall A, 𝟏 • A ≤ cl A.
  Definition cl_neutrality_r_1  := forall A, A ≤ cl (A • 𝟏).
  Definition cl_neutrality_r_2  := forall A, A • 𝟏 ≤ cl A.

  Lemma m_cl_neutrality_l_1 : m_neutrality_l -> cl_neutrality_l_1.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_l_2 : m_neutrality_l -> cl_neutrality_l_2.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_r_1 : m_neutrality_r -> cl_neutrality_r_1.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_r_2 : m_neutrality_r -> cl_neutrality_r_2.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Hypothesis cl_neutral_l_1 : cl_neutrality_l_1.
  Hypothesis cl_neutral_l_2 : cl_neutrality_l_2.
  Hypothesis cl_neutral_r_1 : cl_neutrality_r_1.
  Hypothesis cl_neutral_r_2 : cl_neutrality_r_2.

  Hint Resolve cl_neutral_l_1 cl_neutral_l_2 cl_neutral_r_1 cl_neutral_r_2.

  Proposition cl_eq_neutral_l A : cl (𝟏 • A) ≃ cl A.
  Proof. split; apply cl_le; auto. Qed.

  Proposition cl_eq_neutral_r A : cl (A • 𝟏) ≃ cl A.
  Proof. split; apply cl_le; auto. Qed.

  Definition one := (cl 𝟏).
  Notation "1" := one.

  Proposition one_closed : closed 1.
  Proof. apply cl_idempotent. Qed.

(* TODO "one_closed cannot be used as a hint."
  Hint Resolve one_closed.
*)

  Proposition tensor_unit_l_1 x : x ≤ 1 ⊛ x.
  Proof.
  etransitivity; [ apply cl_neutral_l_1 | ].
  apply cl_monotone; apply compose_monotone; unfold one; auto.
  Qed.

  Proposition tensor_unit_l_2 x : closed x -> 1 ⊛ x ≤ x.
  Proof.
  intros Hc; etransitivity; [ | apply Hc ].
  apply cl_le; auto.
  etransitivity; [ apply cl_stable_l | ].
  apply cl_le; auto.
  Qed.

  Proposition tensor_unit_r_1 x : x ≤ x ⊛ 1.
  Proof.
  etransitivity; [ apply cl_neutral_r_1 | ].
  apply cl_monotone; apply compose_monotone; unfold one; auto.
  Qed.

  Proposition tensor_unit_r_2 x : closed x -> x ⊛ 1 ≤ x.
  Proof.
  intros Hc; etransitivity; [ | apply Hc ].
  apply cl_le; auto.
  etransitivity; [ apply cl_stable_r | ].
  apply cl_le; auto.
  Qed.

  Hint Resolve tensor_unit_l_1 tensor_unit_l_2 tensor_unit_r_1 tensor_unit_r_2.

  Proposition tensor_unit_l x : closed x -> 1 ⊛ x ≃ x.
  Proof.
  intros H; split.
  revert H; apply tensor_unit_l_2.
  apply tensor_unit_l_1.
  Qed.

  Proposition tensor_unit_r x : closed x -> x ⊛ 1 ≃ x.
  Proof.
  intros H; split.
  revert H; apply tensor_unit_r_2.
  apply tensor_unit_r_1.
  Qed.

  Hint Resolve tensor_unit_l tensor_unit_r.


  (* Commutativity *)

  Definition m_commutativity := forall x y, x • y = y • x.

  Definition cl_commutativity := forall x y, x • y ≤ cl (y • x).

  Lemma m_cl_commutativity : m_commutativity -> cl_commutativity.
  Proof. intros Hm x y; rewrite Hm; auto. Qed.

  Hypothesis cl_commute : cl_commutativity.

  Hint Resolve cl_commute.

  Proposition cl_eq_commute x y : cl (x • y) ≃ cl (y • x).
  Proof. split; apply cl_le; auto. Qed.

  Hint Resolve cl_eq_commute.

  Proposition cl_stable_l_imp_stable_r : cl_stability_l -> cl_stability_r.
  Proof.
  intros Hl x y.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  etransitivity; [ apply Hl | ].
  apply cl_le; auto.
  Qed.

  Proposition cl_stable_r_imp_stable_l : cl_stability_r -> cl_stability_l.
  Proof.
  intros Hl x y.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  etransitivity; [ apply Hl | ].
  apply cl_le; auto.
  Qed.

  Proposition cl_stable_l_imp_stable : cl_stability_l -> cl_stability.
  Proof. auto. Qed.

  Proposition tensor_commute x y : x ⊛ y ≤ y ⊛ x.
  Proof. simpl; apply cl_le; auto. Qed.

  Hint Resolve tensor_commute.

  Proposition tensor_eq_commute x y : x ⊛ y ≃ y ⊛ x.
  Proof. split; auto. Qed.

  Proposition cl_associative_l_imp_r : cl_associativity_l -> cl_associativity_r.
  Proof.
  intros Ha a b c.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  transitivity (cl (c • (b • a))); auto.
  apply cl_le; auto.
  etransitivity; [ apply Ha | ].
  apply cl_le; auto.
  transitivity (cl ((b • c) • a)); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_neutrality_l_imp_r_1 : cl_neutrality_l_1 -> cl_neutrality_r_1.
  Proof. intros Hn x; (etransitivity; [ apply Hn | ]); apply cl_le; auto. Qed.

  Proposition cl_neutrality_l_imp_r_2 : cl_neutrality_l_2 -> cl_neutrality_r_2.
  Proof. intros Hn x; (etransitivity; [ apply cl_commute | ]); apply cl_le; auto. Qed.


  (* Axioms for Greatest Lower Bound *)

  Variable mglb : M -> M -> M.
  Infix "⊓" := mglb (at level 50, no associativity).
  Hypothesis mglb_in : forall x y z, x ≤ y -> x ≤ z -> x ≤ y ⊓ z.
  Hypothesis mglb_out_l : forall x y, x ⊓ y ≤ x.
  Hypothesis mglb_out_r : forall x y, x ⊓ y ≤ y.

  Hint Resolve mglb_in mglb_out_l mglb_out_r.

  Proposition mglb_monotone x1 x2 y1 y2 : x1 ≤ y1 -> x2 ≤ y2 -> x1 ⊓ x2 ≤ y1 ⊓ y2.
  Proof. intros H1 H2; apply mglb_in; (etransitivity; [ | eassumption ]); auto. Qed.

  Hint Resolve mglb_monotone.

  Proposition mglb_comm x y : x ⊓ y ≃ y ⊓ x.
  Proof. split; apply mglb_in; auto. Qed.

  Proposition mglb_closed x y : closed x -> closed y -> closed (x ⊓ y).
  Proof.
  intros Hcx Hcy; apply mglb_in.
  - etransitivity; [ | apply Hcx ]; apply cl_monotone; auto.
  - etransitivity; [ | apply Hcy ]; apply cl_monotone; auto.
  Qed.

  Variable mtop : M.
  Hypothesis mtop_greatest : forall x, x ≤ mtop.

  Proposition mtop_closed : closed mtop.
  Proof. apply mtop_greatest. Qed.

  Notation lmglb := (fold_right mglb mtop).

  Fact lmglb_closed l : Forall_Type closed l -> closed (lmglb l).
  Proof. induction 1; [ apply mtop_closed | apply mglb_closed ]; auto. Qed.


  (* Exponentials *)

  Variable k : M.

  Definition sub_monoid_hyp_1 := 𝟏 ≤ cl k.
  Definition sub_monoid_hyp_2 := k • k ≤ k.
  Definition sub_J_hyp_1 := k ≤ 1.
  Definition sub_J_hyp_2 := forall x, x ≤ k -> x ≤ x ⊛ x.

  Hypothesis sub_monoid_1 : sub_monoid_hyp_1.
  Hypothesis sub_monoid_2 : sub_monoid_hyp_2.
  Hypothesis sub_J_1 : sub_J_hyp_1.
  Hypothesis sub_J_2 : sub_J_hyp_2.

  Proposition k_compose x y : (k ⊓ x) • (k ⊓ y) ≤ k ⊓ (x • y).
  Proof.
  apply mglb_in.
  - etransitivity ; [ | apply sub_monoid_2 ].
    apply compose_monotone; auto.
  - apply compose_monotone; auto.
  Qed.

  Definition bang A := cl (k ⊓ A).

  Notation "❗ A" := (bang A) (at level 40, no associativity).

  Fact store_inc_unit A : ❗ A ≤ 1.
  Proof. transitivity (cl k); [ apply cl_monotone | apply cl_le]; auto. Qed.

  Hint Resolve store_inc_unit.

  Proposition store_closed x : closed (❗x).
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition store_dec x : closed x -> ❗x ≤ x.
  Proof. intros ?; transitivity (cl x); try apply cl_monotone; auto. Qed.

  Global Instance store_monotone : Proper (R ==> R) bang.
  Proof. intros ? ? ?; apply cl_monotone; auto. Qed.

  Hint Resolve store_monotone.

  Global Instance store_congruence : Proper (eqrel R ==> eqrel R) bang.
  Proof. intros ? ? [? ?]; split; auto. Qed.

  Proposition store_der x y : closed y -> ❗x ≤ y -> ❗x ≤ ❗y.
  Proof.
  unfold bang; intros H1 H2; apply cl_monotone; apply mglb_in; auto.
  etransitivity; [ | apply H2 ]; auto.
  Qed.

  Proposition store_unit_1 : 1 ≤ ❗mtop.
  Proof. apply cl_le; auto ; (etransitivity; [ apply sub_monoid_1 | ]); apply cl_monotone; auto. Qed.

  Proposition store_unit_2 : ❗mtop ≤ 1.
  Proof. apply cl_le; trivial; transitivity k; auto. Qed.

  Hint Resolve store_unit_1 store_unit_2.

  Proposition store_unit : 1 ≃ ❗mtop.
  Proof. split; auto. Qed.

  Hint Resolve store_unit.

  Proposition store_comp_2 x y : ❗(x ⊓ y) ≤ ❗x ⊛ ❗y.
  Proof.
  apply cl_le; trivial.
  transitivity (cl ((k ⊓ (x ⊓ y)) • (k ⊓ (x ⊓ y)))).
  - apply sub_J_2; auto.
  - apply cl_monotone.
    apply compose_monotone; (etransitivity; [ | apply cl_increase ]); auto.
  Qed.

  Proposition store_comp x y : closed x -> closed y -> ❗x ⊛ ❗y ≃ ❗(x ⊓ y).
  Proof.
  intros Hcx Hcy; split.
  - transitivity (cl ((k ⊓ x) • (k ⊓ y))).
    + apply cl_le; trivial; apply cl_stable; auto.
    + apply cl_monotone.
      apply mglb_in; [ | apply mglb_in ].
      * etransitivity; [ | apply sub_monoid_2].
        apply compose_monotone; auto.
      * etransitivity; [ | apply tensor_unit_r_2 ]; auto.
        etransitivity; [ | apply cl_increase ].
        apply compose_monotone; auto.
        etransitivity; [ apply mglb_out_l | apply sub_J_1 ].
      * etransitivity; [ | apply tensor_unit_l_2 ]; auto.
        etransitivity; [ | apply cl_increase ].
        apply compose_monotone; auto.
        etransitivity; [ apply mglb_out_l | apply sub_J_1 ].
  - apply store_comp_2.
  Qed.

  Proposition store_compose_idem x : ❗x ≤ ❗x ⊛ ❗x.
  Proof. transitivity (❗(x ⊓ x)); [ apply store_monotone | apply store_comp_2 ]; auto. Qed.


  Notation ltensor := (fold_right (fun x y => x ⊛ y) 1).

  Proposition ltensor_store l : Forall_Type closed l -> ltensor (map bang l) ≃ ❗(lmglb l).
  Proof.
  unfold ltensor, lmglb.
  induction 1; simpl; auto.
  transitivity (❗ x ⊛ ❗(lmglb l)).
  - apply tensor_congruent; auto; reflexivity.
  - apply store_comp; auto.
    apply lmglb_closed; auto.
  Qed.

  Notation lcompose := (fold_right compose unit).

  Fact lcompose_nil : lcompose nil = unit.
  Proof. auto. Qed.

  Fact lcompose_cons f l : lcompose (f :: l) = f • lcompose l.
  Proof. auto. Qed.

  Fact lcompose_store l : cl (lcompose (map (fun x => ❗(cl x)) l)) ≃ ❗ (lmglb (map cl l)).
  Proof.
  induction l; split; simpl; auto; try (destruct IHl as [IHl1 IHl2]).
  - apply cl_le; auto.
    transitivity (❗(cl a) • cl(❗ (lmglb (map cl l)))).
    + apply compose_monotone; auto.
      etransitivity; [ | etransitivity; [apply IHl1 | ] ]; auto; apply cl_increase.
    + etransitivity; [ apply cl_stable_r | ]; simpl.
      etransitivity; [ apply store_comp | ]; auto.
      apply lmglb_closed; auto.
      clear IHl1 IHl2; induction l; simpl; auto.
  - transitivity (cl(❗(cl a) • (❗ (lmglb (map cl l))))).
    + etransitivity; [ | apply store_comp_2 ]; auto.
    + apply cl_le; auto.
  Qed.

End ClosureMagma.


Section ClosureSubsetMagma.

  Context { M : Type }.
  Implicit Types A B : M -> Type.

  Definition subset A B := forall x, A x -> B x.

  Global Instance subset_refl : Reflexive subset := fun X a P => P.
  Global Instance subset_trans : Transitive subset := fun X Y Z P Q a H => Q a (P a H).
  Global Instance subset_preorder : PreOrder subset :=
    { PreOrder_Reflexive := subset_refl; PreOrder_Transitive := subset_trans }.

  Hint Resolve subset_refl subset_trans subset_preorder.

  Definition eqset := eqrel subset.

  Infix "⊆" := subset (at level 75, no associativity).
  Infix "≃" := eqset (at level 75, no associativity).
  Infix "∩" := (fun A B z => A z * B z : Type)%type (at level 50, left associativity).
  Infix "∪" := (fun A B z => A z + B z : Type)%type (at level 50, left associativity).
  Notation sg := (@eq _ : _ -> _ -> Type).

  Fact sg_subset A x : A x ≡ sg x ⊆ A.
  Proof. split; intros; auto; intros ? []; trivial. Qed.

  Context { CL : @ClosureOp _ subset }.
  Notation closed := (fun x => cl x ⊆ x).

  (* Intersection and Union *)
  Definition glb A B := A ∩ B.
  Definition lub A B := cl (A ∪ B).
  Infix "⊓" := glb (at level 50, no associativity).
  Infix "⊔" := lub (at level 50, no associativity).

  Proposition glb_in A B C  : C ⊆ A -> C ⊆ B -> C ⊆ A ⊓ B.
  Proof. simpl; split; auto. Qed.

  Proposition glb_out_l A B : A ⊓ B ⊆ A.
  Proof. unfold glb; simpl; red; tauto. Qed.

  Proposition glb_out_r A B : A ⊓ B ⊆ B.
  Proof. unfold glb; simpl; red; tauto. Qed.

  Proposition lub_closed A B : closed (A ⊔ B).
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition lub_out A B C : closed C -> A ⊆ C -> B ⊆ C -> A ⊔ B ⊆ C.
  Proof.
  simpl; intros H1 H2 H3.
  apply subset_trans with (2 := H1), cl_monotone.
  intros ? [ ]; auto.
  Qed.

  Proposition lub_in_l A B  : A ⊆ A ⊔ B.
  Proof. apply subset_trans with (2 := cl_increase _); red; tauto. Qed.

  Proposition lub_in_r A B  : B ⊆ A ⊔ B.
  Proof. apply subset_trans with (2 := cl_increase _); red; tauto. Qed.

  Definition top := (fun _ : M => True).

  Proposition top_greatest A : A ⊆ top.
  Proof. intros x Hx; apply I. Qed.

  Definition zero := (cl ((fun _ : M => False) : M -> Type)).
  Notation "0" := zero.

  Proposition zero_closed : closed zero.
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition zero_least A : closed A -> zero ⊆ A.
  Proof. intro H; apply subset_trans with (2 := H), cl_monotone; red; tauto. Qed.


  Variable compose : M -> M -> M.
  Variable unit : M.

  (* Composition lifted to subsets *)
  Inductive composes A B : M -> Type :=
    In_composes : forall a b, A a -> B b -> composes A B (compose a b).

  Infix "∘" := composes (at level 50, no associativity).

  Global Instance composes_monotone : Proper (subset ==> subset ==> subset) composes.
  Proof. intros X1 Y1 H1 X2 Y2 H2 x [a b Ha Hb]; constructor; auto. Qed.

  Global Instance composes_compat : Proper (eqset ==> eqset ==> eqset) composes.
  Proof. intros X1 Y1 [H1 H2] X2 Y2 [H3 H4]; split; apply composes_monotone; auto. Qed.

  Lemma m_pwr_associativity : m_associativity compose -> m_associativity_rel composes eqset.
  Proof.
  intros Hass x y z; split; intros a Ha.
  - inversion Ha; inversion X0.
    rewrite Hass.
    repeat constructor; assumption.
  - inversion Ha; inversion X.
    rewrite <- Hass.
    repeat constructor; assumption.
  Qed.

  Lemma m_pwr_neutrality_l : m_neutrality_l compose unit -> m_neutrality_l_rel composes (sg unit) eqset.
  Proof.
  intros Hc x; split; intros a Ha.
  - inversion Ha; subst.
    rewrite Hc; assumption.
  - rewrite <- Hc.
    constructor; auto.
  Qed.

  Lemma m_pwr_neutrality_r : m_neutrality_r compose unit -> m_neutrality_r_rel composes (sg unit) eqset.
  Proof.
  intros Hc x; split; intros a Ha.
  - inversion Ha; subst.
    rewrite Hc; assumption.
  - rewrite <- Hc.
    constructor; auto.
  Qed.

  Lemma m_pwr_cl_neutrality_l_2 : m_neutrality_l compose unit -> cl_neutrality_l_2 composes (sg unit).
  Proof.
  intros Hc x.
  etransitivity; [ | apply cl_increase ].
  intros z Hz; inversion Hz; subst; rewrite Hc; auto.
  Qed.

  Lemma m_pwr_cl_neutrality_r_2 : m_neutrality_r compose unit -> cl_neutrality_r_2 composes (sg unit).
  Proof.
  intros Hc x.
  etransitivity; [ | apply cl_increase ].
  intros z Hz; inversion Hz; subst; rewrite Hc; auto.
  Qed.


  (* Adjunct *)
  Definition magicwand_l A B c := A ∘ sg c ⊆ B.
  Infix "⊸" := magicwand_l (at level 51, right associativity).

  Proposition magicwand_l_adj_l A B C : B ∘ A ⊆ C -> A ⊆ B ⊸ C.
  Proof.
  intros H x Hx y Hy.
  apply H; revert Hy; apply composes_monotone; [ reflexivity | ].
  apply sg_subset; assumption.
  Qed.

  Proposition magicwand_l_adj_r A B C : A ⊆ B ⊸ C -> B ∘ A ⊆ C.
  Proof.
  intros H x Hx.
  destruct Hx as [ b a Hb Ha ].
  apply (H _ Ha).
  constructor; auto.
  Qed.

  Definition magicwand_r B A c := sg c ∘ A ⊆ B.
  Infix "⟜" := magicwand_r (at level 52, left associativity).

  Proposition magicwand_r_adj_l A B C : A ∘ B ⊆ C -> A ⊆ C ⟜ B.
  Proof.
  intros H x Hx y Hy.
  apply H; revert Hy; apply composes_monotone; [ | reflexivity ].
  apply sg_subset; auto.
  Qed.

  Proposition magicwand_r_adj_r A B C : A ⊆ C ⟜ B -> A ∘ B ⊆ C.
  Proof.
  intros H x Hx.
  destruct Hx as [ a b Ha Hb ].
  apply (H _ Ha).
  constructor; auto.
  Qed.

  Hint Resolve magicwand_l_adj_l magicwand_l_adj_r magicwand_r_adj_l magicwand_r_adj_r.


  (* Distributivity *)
  Infix "⊛" := (tensor composes) (at level 59).
  Notation "1" := (@one _ _ CL (sg unit)).

  Hypothesis cl_stable_l : cl_stability_l composes.
  Hypothesis cl_stable_r : cl_stability_r composes.

  Hint Resolve (@cl_idempotent _ _ CL) cl_stable_l cl_stable_r (cl_stable _ cl_stable_l cl_stable_r).
  Hint Resolve (@magicwand_l_closed _ _ _ CL _ _ cl_stable_r magicwand_l magicwand_l_adj_l magicwand_l_adj_r).
  Hint Resolve (@magicwand_r_closed _ _ _ CL _ _ cl_stable_l magicwand_r magicwand_r_adj_l magicwand_r_adj_r).

  Proposition tensor_zero_distrib_l A : 0 ⊛ A ⊆ 0.
  Proof. unfold zero; apply (@adjunction_r_r _ _ _ CL _ magicwand_r); auto; apply zero_least; auto. Qed.

  Proposition tensor_zero_distrib_r A : A ⊛ zero ⊆ zero.
  Proof. unfold zero; apply (@adjunction_l_r _ _ _ CL _ magicwand_l); auto; apply zero_least; auto. Qed.

  Hint Immediate tensor_zero_distrib_l tensor_zero_distrib_r.

  Proposition tensor_lub_distrib_l A B C : (A ⊔ B) ⊛ C ⊆ (A ⊛ C) ⊔ (B ⊛ C).
  Proof.
  unfold lub; apply (@adjunction_r_r _ _ _ CL _ magicwand_r), lub_out; auto;
   eapply (@adjunction_r_l _ _ _ CL composes); auto;
   intros ? ? ; apply (@cl_increase _ _ CL); auto.
  Qed.

  Proposition tensor_lub_distrib_r A B C : C ⊛ (A ⊔ B) ⊆ (C ⊛ A) ⊔ (C ⊛ B).
  Proof.
  unfold lub; apply (@adjunction_l_r _ _ _ CL _ magicwand_l), lub_out; auto;
    eapply (@adjunction_l_l _ _ _ CL composes); auto;
    intros ? ? ; apply (@cl_increase _ _ CL); auto.
  Qed.


  (* Exponentials *)
  (* J := { x | x ∈ 1 /\ x ∈ x ⊛ x } *)

  Let J x := (1 x * (sg x ⊛ sg x) x)%type.

  Let J_inv x : J x -> 1 x * (sg x ⊛ sg x) x.
  Proof. auto. Qed.

  Variable K : M -> Type.

  Definition pwr_sub_monoid_hyp_1 := ((cl K) unit).
  Definition pwr_sub_monoid_hyp_2 := (K ∘ K ⊆ K).
  Definition pwr_sub_J_hyp := (K ⊆ J).

  Proposition sub_monoid_1 : pwr_sub_monoid_hyp_1 -> @sub_monoid_hyp_1 _ subset CL (sg unit) K.
  Proof. intros Hpwr x Hx; rewrite <- Hx; assumption. Qed.

  Proposition sub_monoid_2 : pwr_sub_monoid_hyp_2 -> @sub_monoid_hyp_2 _ subset composes K.
  Proof. auto. Qed.

  Proposition sub_J_1 : pwr_sub_J_hyp -> @sub_J_hyp_1 _ subset CL (sg unit) K.
  Proof. intros Hpwr x Hx; apply J_inv; auto. Qed.

  Proposition sub_J_2 : pwr_sub_J_hyp -> @sub_J_hyp_2 _ subset CL composes K.
  Proof.
  intros Hpwr X HX x Hx.
  assert ((sg x ⊛ sg x) x) as Hsg by (apply J_inv, Hpwr; auto).
  assert ((sg x ∘ sg x) ⊆ X ∘ X) as Hc by (intros z Hz; inversion Hz; subst; constructor; auto).
  apply (@cl_monotone _ subset CL) in Hc; apply Hc; auto.
  Qed.

End ClosureSubsetMagma.


Module SetNotations.

  Infix "⊆" := subset (at level 75, no associativity).
  Infix "≃" := eqset (at level 75, no associativity).
  Infix "∩" := (fun A B z => A z * B z : Type)%type (at level 50, left associativity).
  Infix "∪" := (fun A B z => A z + B z : Type)%type (at level 50, left associativity).
  Notation sg := (@eq _ : _ -> _ -> Type).

End SetNotations.

