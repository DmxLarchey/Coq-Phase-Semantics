(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*         CeCILL v2 FREE SOFTWARE LICENSE AGREEMENT          *)
(**************************************************************)

(*   Adapted by Olivier Laurent [**]                          *)
(*                                                            *)
(*                              [**] Affiliation LIP -- CNRS  *)


Require Import CRelationClasses CMorphisms.
Require Import List_Type.

Require Import utils_tac.

Set Implicit Arguments.

(* equivalence at Type *)
Notation "X ≡ Y" := ((X->Y)*(Y->X))%type (at level 80, format "X  ≡  Y", no associativity).

Section ClosurePreOrder.

  Context { M : Type }.

  (* TODO equivalence generated by a PreOrder *)
  Definition eqrel (S : M -> M -> Type) x y := ((S x y) * (S y x))%type.

  Global Instance eqrel_refl S (POS : PreOrder S) : Reflexive (eqrel S) :=
    fun x => (@PreOrder_Reflexive _ _ POS x, @PreOrder_Reflexive _ _ POS x).
  Global Instance eqrel_sym S (POS : PreOrder S) : Symmetric (eqrel S) :=
    fun _ _ H => match H with (H1, H2) => (H2, H1) end.
  Global Instance eqrel_trans S (POS : PreOrder S) : Transitive (eqrel S) :=
    fun _ _ _ P Q =>
    match P, Q with (P1,P2), (Q1,Q2) => (@PreOrder_Transitive _ _ POS _ _ _ P1 Q1,
                                         @PreOrder_Transitive _ _ POS _ _ _ Q2 P2) end.
  Global Instance eqrel_equiv S (POS : PreOrder S) : Equivalence (eqrel S) :=
    { Equivalence_Reflexive := eqrel_refl POS;
      Equivalence_Symmetric := eqrel_sym POS;
      Equivalence_Transitive := eqrel_trans POS }.

  Global Instance eq_eqrel S (POS : PreOrder S) : Proper (eq ==> eqrel S) id.
  Proof. split; subst; reflexivity. Qed.

  Context { R : M -> M -> Type }.
  Variable PO : PreOrder R.

  Infix "≤" := R (at level 75, no associativity).
  Infix "≃" := (eqrel R) (at level 75, no associativity).

  Hint Resolve (eqrel_refl PO) (eqrel_trans PO).
  Hint Immediate (eqrel_sym PO).

  Class ClosureOp := {
    cl          : M -> M;
    cl_increase : forall x, x ≤ cl x;
    cl_monotone : forall x y, x ≤ y -> cl x ≤ cl y;
    cl_idempotent : forall x, cl (cl x) ≤ cl x }.

  Context { CL : ClosureOp }.

  Proposition cl_le x y : x ≤ cl y -> cl x ≤ cl y.
  Proof.
  intros; transitivity (cl (cl y)); [ apply cl_monotone; assumption | apply cl_idempotent ].
  Qed.

  Proposition le_cl x y : cl x ≤ cl y -> x ≤ cl y.
  Proof. intros ; transitivity (cl x); [ apply cl_increase | assumption ]. Qed.

  Fact cl_eq A B : A ≃ B -> cl A ≃ cl B.
  Proof. intros []; split; apply cl_monotone; assumption. Qed.

  Notation closed := (fun x => cl x ≤ x).

  Fact cl_closed x y : closed y -> x ≤ y -> cl x ≤ y.
  Proof. intros; transitivity (cl y); [ apply cl_monotone | ] ; assumption. Qed.

End ClosurePreOrder.


Section ClosureMagma.

  Context { M : Type } { R : M -> M -> Type }.
  Variable PO : PreOrder R.
  Context { CL : @ClosureOp _ R }.

  Hint Resolve (@PreOrder_Reflexive _ _ PO).
  Hint Resolve (@cl_increase _ _ CL) (@cl_monotone _ _ CL) (@cl_idempotent _ _ CL).

  Variable compose : M -> M -> M.

  Infix "≤" := R (at level 75, no associativity).
  Infix "≃" := (eqrel R) (at level 75, no associativity).
  Infix "•" := compose (at level 45, no associativity).
  Notation closed := (fun x => cl x ≤ x).

  Hypothesis compose_monotone : Proper (R ==> R ==> R) compose.

  Hint Resolve compose_monotone.


  (* Stability *)

  Definition cl_stability   := forall x y, cl x • cl y ≤ cl (x • y).
  Definition cl_stability_l := forall x y, cl x •    y ≤ cl (x • y).
  Definition cl_stability_r := forall x y,    x • cl y ≤ cl (x • y).

  Proposition cl_stable_imp_stable_l : cl_stability -> cl_stability_l.
  Proof.
  intros Hs x y.
  transitivity (cl x • cl y); auto.
  apply compose_monotone; auto.
  Qed.

  Proposition cl_stable_imp_stable_r : cl_stability -> cl_stability_r.
  Proof.
  intros Hs x y.
  transitivity (cl x • cl y); auto.
  apply compose_monotone; auto.
  Qed.

  Proposition cl_stable_lr_imp_stable : cl_stability_l -> cl_stability_r -> cl_stability.
  Proof.
  intros Hsl Hsr x y.
  etransitivity; [ | apply cl_idempotent ].
  transitivity (cl (cl x • y)); auto.
  Qed.

  Hint Resolve cl_stable_imp_stable_l cl_stable_imp_stable_r cl_stable_lr_imp_stable.

  Hypothesis cl_stable_l : cl_stability_l.
  Hypothesis cl_stable_r : cl_stability_r.

  Proposition cl_stable : cl_stability.
  Proof. auto. Qed.

  Hint Resolve cl_stable.

  Proposition cl_eq_stable_l x y : cl (cl x • y) ≃ cl (x • y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Proposition cl_eq_stable_r x y : cl (x • cl y) ≃ cl (x • y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Proposition cl_eq_stable x y : cl (cl x • cl y) ≃ cl (x • y).
  Proof.
  split.
  apply cl_le; auto.
  apply cl_monotone, compose_monotone; auto.
  Qed.

  Hint Immediate cl_eq_stable_l cl_eq_stable_r cl_eq_stable.


  (* Congruence *)

  Proposition cl_congruent_l x y z : x ≤ cl y -> z • x ≤ cl (z • y).
  Proof.
  intros H.
  transitivity (cl (z • cl y)).
  - apply le_cl, cl_monotone, compose_monotone; auto.
  - transitivity (cl (cl (z • y))); auto.
  Qed.

  Proposition cl_congruent_r x y z : x ≤ cl y -> x • z ≤ cl (y • z).
  Proof.
  intros H.
  transitivity (cl (cl y • z)).
  - apply le_cl, cl_monotone, compose_monotone; auto.
  - transitivity (cl (cl (y • z))); auto.
  Qed.

  Hint Resolve cl_congruent_l cl_congruent_r.

  Proposition cl_eq_congruent_l x y z : cl x ≃ cl y -> cl (z • x) ≃ cl (z • y).
  Proof.
  intros [H1 H2].
  assert (H3 := le_cl _ _ _ H1).
  assert (H4 := le_cl _ _ _ H2).
  split; apply cl_le; auto;
    (etransitivity ; [ | apply cl_stable_r ]);
    apply compose_monotone; auto.
  Qed.

  Proposition cl_eq_congruent_r x y z : cl x ≃ cl y -> cl (x • z) ≃ cl (y • z).
  Proof.
  intros [H1 H2].
  assert (H3 := le_cl _ _ _ H1).
  assert (H4 := le_cl _ _ _ H2).
  split; apply cl_le; auto;
    (etransitivity ; [ | apply cl_stable_r ]);
    apply compose_monotone; auto.
  Qed.

  Hint Resolve cl_eq_congruent_l cl_eq_congruent_r.

  Proposition cl_eq_congruent x y z t : cl x ≃ cl y -> cl z ≃ cl t -> cl (x • z) ≃ cl (y • t).
  Proof. intros; transitivity (cl (y • z)); auto. Qed.


  (* Associativity *)

  Definition m_associativity := forall x y z, x • (y • z) = (x • y) • z.

  Definition cl_associativity_l := forall x y z, x • (y • z) ≤ cl ((x • y) • z).
  Definition cl_associativity_r := forall x y z, (x • y) • z ≤ cl (x • (y • z)).

  Lemma m_cl_associativity_l : m_associativity -> cl_associativity_l.
  Proof. intros Ha x y z; rewrite Ha; auto. Qed.

  Lemma m_cl_associativity_r : m_associativity -> cl_associativity_r.
  Proof. intros Ha x y z; rewrite Ha; auto. Qed.

  Hypothesis cl_associative_l : cl_associativity_l.
  Hypothesis cl_associative_r : cl_associativity_r.

  Hint Immediate cl_associative_l cl_associative_r.

  Proposition cl_eq_associative x y z : cl (x • (y • z)) ≃ cl ((x • y) • z).
  Proof. split; auto; apply cl_le; auto. Qed.

  Hint Immediate cl_eq_associative.


  (* Tensor *)

  Definition tensor x y := (cl (x • y)).
  Infix "⊛" := tensor (at level 59).

  Proposition tensor_closed x y : closed (x ⊛ y).
  Proof. simpl; apply cl_idempotent. Qed.

  Instance tensor_monotone : Proper (R ==> R ==> R) tensor.
  Proof. simpl; intros ? ? ? ? ? ?; apply cl_monotone, compose_monotone; auto. Qed.

  Global Instance tensor_congruent : Proper (eqrel R ==> eqrel R ==> eqrel R) tensor.
  Proof. intros ? ? ? ? ? ?; apply cl_eq_congruent; apply cl_eq; auto. Qed.

  Proposition tensor_associative x y z : (x ⊛ y) ⊛ z ≃ x ⊛ (y ⊛ z).
  Proof.
  symmetry; (etransitivity ; [ apply cl_eq_stable_r | ]).
  symmetry; (etransitivity ; [ apply cl_eq_stable_l | ]).
  symmetry; apply cl_eq_associative.
  Qed.

  Proposition tensor_associative_l x y z : x ⊛ (y ⊛ z) ≤ (x ⊛ y) ⊛ z.
  Proof. apply tensor_associative. Qed.

  Proposition tensor_associative_r x y z : (x ⊛ y) ⊛ z ≤ x ⊛ (y ⊛ z).
  Proof. apply tensor_associative. Qed.

  Hint Resolve tensor_associative_l tensor_associative_r.


  (* Adjunct *)

  Variable magicwand_l : M -> M -> M.
  Infix "⊸" := magicwand_l (at level 51, right associativity).

  Hypothesis magicwand_l_adj_l : forall x y z, y • x ≤ z -> x ≤ y ⊸ z.
  Hypothesis magicwand_l_adj_r : forall x y z, x ≤ y ⊸ z -> y • x ≤ z.

  Global Instance magicwand_l_monotone : Proper (R --> R ==> R) magicwand_l.
  Proof.
  intros ? ? ? ? ? HB.
  apply magicwand_l_adj_l.
  etransitivity; [ | apply HB ].
  transitivity (x • (x ⊸ x0)).
  - apply compose_monotone; auto.
  - apply magicwand_l_adj_r; auto.
  Qed.

  Hint Resolve magicwand_l_monotone.

  Proposition cl_magicwand_l_1 x y : cl (x ⊸ cl y) ≤ x ⊸ cl y.
  Proof.
  apply magicwand_l_adj_l.
  transitivity (cl (x • (x ⊸ cl y))); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_magicwand_l_2 x y : cl x ⊸ y ≤ x ⊸ y.
  Proof. apply magicwand_l_monotone; auto; red; auto. Qed.

  Hint Immediate cl_magicwand_l_1 cl_magicwand_l_2.

  Proposition cl_magicwand_l_3 x y : x ⊸ cl y ≤ cl x ⊸ cl y.
  Proof.
  apply magicwand_l_adj_l.
  etransitivity; [ apply cl_stable_l | ].
  apply cl_le, magicwand_l_adj_r; auto.
  Qed.

  Hint Immediate cl_magicwand_l_3.

  Proposition magicwand_l_closed x y : closed y -> closed (x ⊸ y).
  Proof.
  simpl; intros ?.
  transitivity (cl (x ⊸ cl y)).
  - apply cl_monotone, magicwand_l_monotone; auto; red; auto.
  - transitivity (x ⊸ cl y); auto.
    apply magicwand_l_monotone; auto; red; auto.
  Qed.

  Hint Resolve magicwand_l_closed.

  Proposition magicwand_l_eq_1 x y : x ⊸ cl y ≃ cl x ⊸ cl y.
  Proof. split; auto. Qed.

  Proposition magicwand_l_eq_2 X Y : cl (X ⊸ cl Y) ≃ X ⊸ cl Y.
  Proof. split; auto. Qed.

  Hint Resolve magicwand_l_eq_1 magicwand_l_eq_2.

  Proposition magicwand_l_eq_3 x y : cl (x ⊸ cl y) ≃ cl x ⊸ cl y.
  Proof. transitivity (x ⊸ cl y); auto. Qed.

  Hint Resolve magicwand_l_eq_3.

  Variable magicwand_r : M -> M -> M.
  Infix "⟜" := magicwand_r (at level 52, left associativity).

  Hypothesis magicwand_r_adj_l : forall x y z, x • y ≤ z -> x ≤ z ⟜ y.
  Hypothesis magicwand_r_adj_r : forall x y z, x ≤ z ⟜ y -> x • y ≤ z.

  Global Instance magicwand_r_monotone : Proper (R ==> R --> R) magicwand_r.
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  intros ? ? ? ? ? HB.
  apply magicwand_r_adj_l.
  transitivity ((x ⟜ x0) • x0).
  - apply compose_monotone; auto.
  - transitivity x; auto.
  Qed.

  Hint Resolve magicwand_r_monotone.

  Proposition cl_magicwand_r_1 x y : cl (cl y ⟜ x) ≤ cl y ⟜ x.
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  apply magicwand_r_adj_l.
  transitivity (cl ((cl y ⟜ x) • x)); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_magicwand_r_2 x y : y ⟜ cl x ≤ y ⟜ x.
  Proof. apply magicwand_r_monotone; auto; red; auto. Qed.

  Hint Immediate cl_magicwand_r_1 cl_magicwand_r_2.

  Proposition cl_magicwand_r_3 x y : cl y ⟜ x ≤ cl y ⟜ cl x.
  Proof.
  apply magicwand_r_adj_l.
  etransitivity; [ apply cl_stable_r | ].
  apply cl_le, magicwand_r_adj_r; auto.
  Qed.

  Hint Immediate cl_magicwand_r_3.

  Proposition magicwand_r_closed x y : closed y -> closed (y ⟜ x).
  Proof.
  clear magicwand_l magicwand_l_adj_l magicwand_l_adj_r.
  simpl; intros ?.
  transitivity (cl (cl y ⟜ x)).
  - apply cl_monotone, magicwand_r_monotone; auto; red; auto.
  - transitivity (cl y ⟜ x); auto.
    apply magicwand_r_monotone; auto; red; auto.
  Qed.

  Hint Resolve magicwand_r_closed.

  Proposition magicwand_r_eq_1 x y : cl y ⟜ x ≃ cl y ⟜ cl x.
  Proof. split; auto. Qed.

  Proposition magicwand_r_eq_2 x y : cl (cl y ⟜ x) ≃ cl y ⟜ x.
  Proof. split; auto. Qed.

  Hint Resolve magicwand_r_eq_1 magicwand_r_eq_2.

  Proposition magicwand_r_eq_3 x y : cl (cl y ⟜ x) ≃ cl y ⟜ cl x.
  Proof. transitivity (cl y ⟜ x); auto. Qed.

  Hint Resolve magicwand_r_eq_3.

  (* Adjunction properties *)
  Proposition adjunction_l_l x y z : closed z -> y ⊛ x ≤ z -> x ≤ y ⊸ z.
  Proof.
  unfold tensor; intros ? H.
  apply magicwand_l_adj_l; (etransitivity; [ | apply H ]); auto.
  Qed.

  Proposition adjunction_l_r x y z : closed z -> x ≤ y ⊸ z -> y ⊛ x ≤ z.
  Proof.
  intros H ?.
  etransitivity; [ | apply H ].
  apply cl_monotone, magicwand_l_adj_r; auto.
  Qed.

  Hint Resolve tensor_congruent adjunction_l_l (* adjunction_l_r *).

  Proposition adjunction_r_l x y z : closed z -> x ⊛ y ≤ z -> x ≤ z ⟜ y.
  Proof.
  unfold tensor; intros ? H.
  apply magicwand_r_adj_l.
  etransitivity; [ | apply H ]; auto.
  Qed.

  Proposition adjunction_r_r x y z : closed z -> x ≤ z ⟜ y -> x ⊛ y ≤ z.
  Proof.
  intros H ?.
  etransitivity; [ | apply H ].
  apply cl_monotone, magicwand_r_adj_r; auto.
  Qed.

  Hint Resolve adjunction_r_l (* adjunction_r_r *).


  (* Unit *)

  Variable unit : M.
  Notation "𝟏" := unit.

  Definition m_neutrality_l := forall x, 𝟏 • x = x.
  Definition m_neutrality_r := forall x, x • 𝟏 = x.

  Definition cl_neutrality_l_1  := forall A, A ≤ cl (𝟏 • A).
  Definition cl_neutrality_l_2  := forall A, 𝟏 • A ≤ cl A.
  Definition cl_neutrality_r_1  := forall A, A ≤ cl (A • 𝟏).
  Definition cl_neutrality_r_2  := forall A, A • 𝟏 ≤ cl A.

  Lemma m_cl_neutrality_l_1 : m_neutrality_l -> cl_neutrality_l_1.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_l_2 : m_neutrality_l -> cl_neutrality_l_2.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_r_1 : m_neutrality_r -> cl_neutrality_r_1.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Lemma m_cl_neutrality_r_2 : m_neutrality_r -> cl_neutrality_r_2.
  Proof. intros Hn x; rewrite Hn; auto. Qed.

  Hypothesis cl_neutral_l_1 : cl_neutrality_l_1.
  Hypothesis cl_neutral_l_2 : cl_neutrality_l_2.
  Hypothesis cl_neutral_r_1 : cl_neutrality_r_1.
  Hypothesis cl_neutral_r_2 : cl_neutrality_r_2.

  Hint Resolve cl_neutral_l_1 cl_neutral_l_2 cl_neutral_r_1 cl_neutral_r_2.

  Proposition cl_eq_neutral_l A : cl (𝟏 • A) ≃ cl A.
  Proof. split; apply cl_le; auto. Qed.

  Proposition cl_eq_neutral_r A : cl (A • 𝟏) ≃ cl A.
  Proof. split; apply cl_le; auto. Qed.

  Definition one := (cl 𝟏).
  Notation "1" := one.

  Proposition one_closed : closed 1.
  Proof. apply cl_idempotent. Qed.

(* TODO "closed_one cannot be used as a hint."
  Hint Resolve closed_one.
*)

  Proposition tensor_unit_l_1 x : x ≤ 1 ⊛ x.
  Proof.
  etransitivity; [ apply cl_neutral_l_1 | ].
  apply cl_monotone; apply compose_monotone; unfold one; auto.
  Qed.

  Proposition tensor_unit_l_2 x : closed x -> 1 ⊛ x ≤ x.
  Proof.
  intros Hc; etransitivity; [ | apply Hc ].
  apply cl_le; auto.
  etransitivity; [ apply cl_stable_l | ].
  apply cl_le; auto.
  Qed.

  Proposition tensor_unit_r_1 x : x ≤ x ⊛ 1.
  Proof.
  etransitivity; [ apply cl_neutral_r_1 | ].
  apply cl_monotone; apply compose_monotone; unfold one; auto.
  Qed.

  Proposition tensor_unit_r_2 x : closed x -> x ⊛ 1 ≤ x.
  Proof.
  intros Hc; etransitivity; [ | apply Hc ].
  apply cl_le; auto.
  etransitivity; [ apply cl_stable_r | ].
  apply cl_le; auto.
  Qed.

  Hint Resolve tensor_unit_l_1 tensor_unit_l_2 tensor_unit_r_1 tensor_unit_r_2.

  Proposition tensor_unit_l x : closed x -> 1 ⊛ x ≃ x.
  Proof.
  intros H; split.
  revert H; apply tensor_unit_l_2.
  apply tensor_unit_l_1.
  Qed.

  Proposition tensor_unit_r x : closed x -> x ⊛ 1 ≃ x.
  Proof.
  intros H; split.
  revert H; apply tensor_unit_r_2.
  apply tensor_unit_r_1.
  Qed.

  Hint Resolve tensor_unit_l tensor_unit_r.


  (* Commutativity *)

  Definition m_commutativity := forall x y, x • y = y • x.

  Definition cl_commutativity := forall x y, x • y ≤ cl (y • x).

  Lemma m_cl_commutativity : m_commutativity -> cl_commutativity.
  Proof. intros Hm x y; rewrite Hm; auto. Qed.

  Hypothesis cl_commute : cl_commutativity.

  Hint Resolve cl_commute.

  Proposition cl_eq_commute x y : cl (x • y) ≃ cl (y • x).
  Proof. split; apply cl_le; auto. Qed.

  Hint Resolve cl_eq_commute.

  Proposition cl_stable_l_imp_stable_r : cl_stability_l -> cl_stability_r.
  Proof.
  intros Hl x y.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  etransitivity; [ apply Hl | ].
  apply cl_le; auto.
  Qed.

  Proposition cl_stable_r_imp_stable_l : cl_stability_r -> cl_stability_l.
  Proof.
  intros Hl x y.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  etransitivity; [ apply Hl | ].
  apply cl_le; auto.
  Qed.

  Proposition cl_stable_l_imp_stable : cl_stability_l -> cl_stability.
  Proof. auto. Qed.

  Proposition tensor_commute x y : x ⊛ y ≤ y ⊛ x.
  Proof. simpl; apply cl_le; auto. Qed.

  Hint Resolve tensor_commute.

  Proposition tensor_eq_commute x y : x ⊛ y ≃ y ⊛ x.
  Proof. split; auto. Qed.

  Proposition cl_associative_l_imp_r : cl_associativity_l -> cl_associativity_r.
  Proof.
  intros Ha a b c.
  etransitivity; [ apply cl_commute | ].
  apply cl_le; auto.
  transitivity (cl (c • (b • a))); auto.
  apply cl_le; auto.
  etransitivity; [ apply Ha | ].
  apply cl_le; auto.
  transitivity (cl ((b • c) • a)); auto.
  apply cl_le; auto.
  Qed.

  Proposition cl_neutrality_l_imp_r_1 : cl_neutrality_l_1 -> cl_neutrality_r_1.
  Proof. intros Hn x; (etransitivity; [ apply Hn | ]); apply cl_le; auto. Qed.

  Proposition cl_neutrality_l_imp_r_2 : cl_neutrality_l_2 -> cl_neutrality_r_2.
  Proof. intros Hn x; (etransitivity; [ apply cl_commute | ]); apply cl_le; auto. Qed.

End ClosureMagma.


Section ClosureSubset.

  Context { M : Type }.
  Implicit Types A B : M -> Type.

  Definition subset A B := forall x, A x -> B x.
  Infix "⊆" := subset (at level 75, no associativity).

  Global Instance subset_refl : Reflexive subset := fun X a P => P.
  Global Instance subset_trans : Transitive subset := fun X Y Z P Q a H => Q a (P a H).
  Global Instance subset_preorder : PreOrder subset :=
    { PreOrder_Reflexive := subset_refl; PreOrder_Transitive := subset_trans }.

  Hint Resolve subset_refl subset_trans subset_preorder.

  Definition eqset := eqrel subset.
  Infix "≃" := eqset (at level 75, no associativity).

  (* intersection and union *)
  Notation "A ∩ B" := (fun z => A z * B z : Type)%type (at level 50, format "A  ∩  B", left associativity).
  Notation "A ∪ B" := (fun z => A z + B z : Type)%type (at level 50, format "A  ∪  B", left associativity).

  (* singleton *)
  Notation sg := (@eq _).

  Fact sg_subset A x : A x ≡ sg x ⊆ A.
  Proof.
  split; intros; auto.
  intros ? []; trivial.
  Qed.


  Context { CL : @ClosureOp _ subset }.
  Notation closed := (fun x => cl x ⊆ x).

  (* Intersection and Union *)
  Definition glb A B := A ∩ B.
  Definition lub A B := cl (A ∪ B).
  Infix "⊓" := glb (at level 50, no associativity).
  Infix "⊔" := lub (at level 50, no associativity).

  Proposition glb_closed A B : closed A -> closed B -> closed (A ⊓ B).
  Proof.
  unfold glb; simpl; intros HA HB x Hx; split;
    [ apply HA | apply HB ]; revert x Hx;
    apply (@cl_monotone _ _ CL) ; red; tauto.
  Qed.

  Proposition lub_closed A B : closed (A ⊔ B).
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition lub_out A B C : closed C -> A ⊆ C -> B ⊆ C -> A ⊔ B ⊆ C.
  Proof.
  simpl; intros H1 H2 H3.
  apply subset_trans with (2 := H1), cl_monotone.
  intros ? [ ]; auto.
  Qed.

  Proposition glb_in A B C : C ⊆ A -> C ⊆ B -> C ⊆ A ⊓ B.
  Proof. simpl; split; auto. Qed.

  Proposition glb_out_l A B  : A ⊓ B ⊆ A.
  Proof. unfold glb; simpl; red; tauto. Qed.

  Proposition glb_out_r A B  : A ⊓ B ⊆ B.
  Proof. unfold glb; simpl; red; tauto. Qed.

  Proposition lub_in_l A B   : A ⊆ A ⊔ B.
  Proof. apply subset_trans with (2 := cl_increase _); red; tauto. Qed.

  Proposition lub_in_r A B   : B ⊆ A ⊔ B.
  Proof. apply subset_trans with (2 := cl_increase _); red; tauto. Qed.

  Proposition glb_comm A B : A ⊓ B ≃ B ⊓ A.
  Proof. unfold glb; split; apply glb_in; red; tauto. Qed.

  Definition top : M -> Type := (fun _ : M => True).
  Definition zero := (cl ((fun _ : M => False) : M -> Type)).

  Proposition top_closed : closed top.
  Proof. unfold top; simpl; intros; red; auto. Qed.

  Proposition zero_closed : closed zero.
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition top_greatest A : A ⊆ top.
  Proof. unfold top; simpl; red; tauto. Qed.

  Proposition zero_least A : closed A -> zero ⊆ A.
  Proof. intro H; apply subset_trans with (2 := H), cl_monotone; red; tauto. Qed.

  Fact mglb_closed l : Forall_Type closed l -> closed (fold_right (fun x y => x ∩ y) top l).
  Proof. induction 1; [ apply top_closed | apply glb_closed ]; auto. Qed.

End ClosureSubset.


Section SubsetMagma.

  Context { M : Type }.
  Implicit Types A B : M -> Type.

  Variable compose : M -> M -> M.

(*
  Infix "•" := compose (at level 45, no associativity).
*)
  Infix "⊆" := (@subset M) (at level 75, no associativity).
  Infix "≃" := (@eqset M) (at level 75, no associativity).
  Notation sg := (@eq _).
  Hint Resolve subset_preorder.

  (* Composition lifted to subsets *)
  Inductive composes A B : M -> Type :=
    In_composes : forall a b, A a -> B b -> composes A B (compose a b).

  Infix "∘" := composes (at level 50, no associativity).

  Global Instance composes_monotone : Proper (subset ==> subset ==> subset) composes.
  Proof. intros X1 Y1 H1 X2 Y2 H2 x [a b Ha Hb]; constructor; auto. Qed.

  Global Instance composes_compat : Proper (eqset ==> eqset ==> eqset) composes.
  Proof. intros X1 Y1 [H1 H2] X2 Y2 [H3 H4]; split; apply composes_monotone; auto. Qed.


  (* Adjunct *)
  Definition magicwand_l A B c := A ∘ sg c ⊆ B.
  Infix "⊸" := magicwand_l (at level 51, right associativity).

  Proposition magicwand_l_adj_l A B C : B ∘ A ⊆ C -> A ⊆ B ⊸ C.
  Proof.
  intros H x Hx y Hy.
  apply H; revert Hy; apply composes_monotone; [ reflexivity | ].
  apply sg_subset; assumption.
  Qed.

  Proposition magicwand_l_adj_r A B C : A ⊆ B ⊸ C -> B ∘ A ⊆ C.
  Proof.
  intros H x Hx.
  destruct Hx as [ b a Hb Ha ].
  apply (H _ Ha).
  constructor; auto.
  Qed.

  Definition magicwand_r B A c := sg c ∘ A ⊆ B.
  Infix "⟜" := magicwand_r (at level 52, left associativity).

  Proposition magicwand_r_adj_l A B C : A ∘ B ⊆ C -> A ⊆ C ⟜ B.
  Proof.
  intros H x Hx y Hy.
  apply H; revert Hy; apply composes_monotone; [ | reflexivity ].
  apply sg_subset; auto.
  Qed.

  Proposition magicwand_r_adj_r A B C : A ⊆ C ⟜ B -> A ∘ B ⊆ C.
  Proof.
  intros H x Hx.
  destruct Hx as [ a b Ha Hb ].
  apply (H _ Ha).
  constructor; auto.
  Qed.

  Hint Resolve magicwand_l_adj_l magicwand_l_adj_r magicwand_r_adj_l magicwand_r_adj_r.


  (* Distributivity *)
  Context { CL : @ClosureOp _ (@subset M) }.
  Notation closed := (fun A => cl A ⊆ A).
  Infix "⊛" := (tensor composes) (at level 59).
  Notation "0" := (@zero _ CL).
  Infix "⊔" := (@lub _ CL) (at level 50, no associativity).

  Hypothesis cl_stable_l : cl_stability_l composes.
  Hypothesis cl_stable_r : cl_stability_r composes.

  Hint Resolve (@cl_idempotent _ _ CL) cl_stable_l cl_stable_r (cl_stable _ cl_stable_l cl_stable_r).
  Hint Resolve (@magicwand_l_closed _ _ _ CL _ _ cl_stable_r magicwand_l magicwand_l_adj_l magicwand_l_adj_r).
  Hint Resolve (@magicwand_r_closed _ _ _ CL _ _ cl_stable_l magicwand_r magicwand_r_adj_l magicwand_r_adj_r).

  Proposition tensor_zero_distrib_l A : 0 ⊛ A ⊆ 0.
  Proof.
  unfold zero; apply (@adjunction_r_r _ _ _ CL _ magicwand_r); auto.
  apply zero_least; auto.
  Qed.

  Proposition tensor_zero_distrib_r A : A ⊛ zero ⊆ zero.
  Proof.
  unfold zero; apply (@adjunction_l_r _ _ _ CL _ magicwand_l); auto.
  apply zero_least; auto.
  Qed.

  Hint Immediate tensor_zero_distrib_l tensor_zero_distrib_r.

  Proposition tensor_lub_distrib_l A B C : (A ⊔ B) ⊛ C ⊆ (A ⊛ C) ⊔ (B ⊛ C).
  Proof.
  unfold lub; apply (@adjunction_r_r _ _ _ CL _ magicwand_r), lub_out; auto;
   eapply (@adjunction_r_l _ _ _ CL composes); auto;
   intros ? ? ; apply (@cl_increase _ _ CL); auto.
  Qed.

  Proposition tensor_lub_distrib_r A B C : C ⊛ (A ⊔ B) ⊆ (C ⊛ A) ⊔ (C ⊛ B).
  Proof.
  unfold lub; apply (@adjunction_l_r _ _ _ CL _ magicwand_l), lub_out; auto;
    eapply (@adjunction_l_l _ _ _ CL composes); auto;
    intros ? ? ; apply (@cl_increase _ _ CL); auto.
  Qed.

(* TODO try to move at magma level ??? *)

  (* Exponentials *)
  (* J := { x | x ∈ 1 /\ x ∈ x ⊛ x } *)

  Variable unit : M.
  Notation "1" := (@one _ _ CL (sg unit)).
  Notation "A ∩ B" := (fun z => A z * B z : Type)%type (at level 50, format "A  ∩  B", left associativity).
  Infix "⊓" := glb (at level 50, no associativity).

  Hypothesis cl_neutral_l_1 : cl_neutrality_l_1 composes (sg unit).
  Hypothesis cl_neutral_l_2 : cl_neutrality_l_2 composes (sg unit).
  Hypothesis cl_neutral_r_1 : cl_neutrality_r_1 composes (sg unit).
  Hypothesis cl_neutral_r_2 : cl_neutrality_r_2 composes (sg unit).

  Hint Resolve cl_neutral_l_1 cl_neutral_l_2 cl_neutral_r_1 cl_neutral_r_2.

  Let J x := (1 x * (sg x ⊛ sg x) x)%type.

  Let In_J : forall x, 1 x -> (sg x ⊛ sg x) x -> J x.
  Proof. split; auto. Qed.

  Let J_inv x : J x -> 1 x * (sg x ⊛ sg x) x.
  Proof. auto. Qed.

  Proposition J_inc_unit : J ⊆ 1.
  Proof. intros ? ?; apply J_inv; auto. Qed.

  Variable K : M -> Type.

  Definition sub_monoid_hyp_1 := ((cl K) unit).
  Definition sub_monoid_hyp_2 := (K ∘ K ⊆ K).
  Definition sub_J_hyp := (K ⊆ J).

  Hypothesis sub_monoid_1 : sub_monoid_hyp_1.
  Hypothesis sub_monoid_2 : sub_monoid_hyp_2.
  Hypothesis sub_J : sub_J_hyp.

  Proposition K_inc_unit : K ⊆ 1.
  Proof. transitivity J; trivial; apply J_inc_unit. Qed.

  Proposition K_compose A B : (K ∩ A) ∘ (K ∩ B) ⊆ K ∩ (A ∘ B).
  Proof.
  intros x Hx.
  split; [ apply sub_monoid_2 | ];
    revert Hx; apply composes_monotone; intros z [Hz1 Hz2]; assumption.
  Qed.

  Definition bang A := cl (K ∩ A).

  Notation "❗ A" := (bang A) (at level 40, no associativity).

  Fact store_inc_unit A : ❗ A ⊆ 1.
  Proof.
  transitivity (cl K).
  - apply cl_monotone; red; tauto.
  - apply cl_le, K_inc_unit; auto.
  Qed.

  Hint Resolve store_inc_unit.

  Proposition store_closed A : closed (❗A).
  Proof. simpl; apply cl_idempotent. Qed.

  Proposition store_dec A : closed A -> ❗A ⊆ A.
  Proof.
  intros HA; simpl.
  transitivity (cl A); trivial.
  apply cl_monotone.
  apply glb_out_r.
  Qed.

  Global Instance store_monotone : Proper (subset ==> subset) bang.
  Proof. intros ? ? ?; apply cl_monotone; intros ? []; split; auto. Qed.

  Hint Resolve store_monotone.

  Global Instance store_congruence : Proper (eqset ==> eqset) bang.
  Proof. intros ? ? [? ?]; split; auto. Qed.

  Proposition store_der A B : closed B -> ❗A ⊆ B -> ❗A ⊆ ❗B.
  Proof.
  unfold bang; intros H1 H2; apply cl_monotone; intros x []; split; auto.
  apply H2; auto.
  apply (@cl_increase _ subset); auto.
  Qed.

  Proposition store_unit_1 : 1 ⊆ ❗top.
  Proof.
  unfold top; apply cl_le; auto.
  intros ? []; apply (@cl_monotone _ subset _ K); auto; red; auto.
  Qed.

  Hint Resolve J_inc_unit.

  Proposition store_unit_2 : ❗top ⊆ 1.
  Proof.
  apply cl_le; trivial.
  transitivity J; auto.
  intros ? []; auto.
  Qed.

  Hint Resolve store_unit_1 store_unit_2.

  Proposition store_unit : 1 ≃ ❗top.
  Proof. split; auto. Qed.

  Hint Resolve store_unit.

  Proposition store_comp A B : closed A -> closed B -> ❗A ⊛ ❗B ≃ ❗(A ⊓ B).
  Proof.
  intros HA HB; split.
  - apply subset_trans with (cl ((K ⊓ A) ∘ (K ⊓ B))).
    + apply cl_le; trivial; apply cl_stable; auto.
    + apply cl_monotone.
      intros x H.
      split; [ | split ].
      * apply sub_monoid_2; revert H; apply composes_monotone; intros z [Hz _]; assumption.
      * refine (@tensor_unit_r_2 _ subset _ _ composes _ (sg unit) _ _ _ _ _); auto.
        apply (@cl_increase _ subset).
        revert H; apply composes_monotone; intros z [Hz1 Hz2]; try assumption.
        apply K_inc_unit; auto.
      * refine (@tensor_unit_l_2 _ subset _ _ composes _ (sg unit) _ _ _ _ _); auto.
        apply (@cl_increase _ subset).
        revert H; apply composes_monotone; intros z [Hz1 Hz2]; try assumption.
        apply K_inc_unit; auto.
  - apply cl_le; trivial.
    intros x (H1 & H2 & H3).
    apply (@cl_monotone _ subset) with (sg x ∘ sg x).
    + apply composes_monotone; intros z Heq; subst; apply (@cl_increase _ subset); auto.
    + apply sub_J in H1; destruct H1; trivial.
  Qed.

  Definition ltensor := fold_right (fun x y => x ⊛ y) 1.
  Definition lcap := fold_right (fun x y => x ∩ y) (@top M).

  Hint Resolve mglb_closed.

  Proposition ltensor_store l : Forall_Type closed l -> ltensor (map bang l) ≃ ❗(lcap l).
  Proof.
  unfold ltensor, lcap.
  induction 1; simpl; auto.
  transitivity (❗ x ⊛ ❗(lcap l)).
  - apply tensor_congruent; auto; [ apply composes_monotone | reflexivity ].
  - apply store_comp; unfold lcap; auto.
  Qed.

  Proposition store_compose_idem A : closed A -> ❗A ⊆ ❗A ⊛ ❗A.
  Proof.
  intros HA.
  transitivity (❗(A ∩ A)).
  - apply store_der. 
    + apply glb_closed; trivial.
    + transitivity A; red; auto.
      apply store_dec; trivial.
  - apply store_comp; trivial.
  Qed.

End SubsetMagma.

